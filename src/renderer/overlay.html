<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PoE2 Modifier Overlay</title>
    <link rel="stylesheet" href="./styles/overlay.css">
    <script type="module" src="./overlay-entry.ts"></script>

        <style>
            /* Login / Logout button state styles */
            #poeLoginBtn.login-state { background:#1e5eb8; color:#fff; border:1px solid #2d74d6; }
            #poeLoginBtn.login-state:hover { background:#256bd1; }
            #poeLoginBtn.logout-state { background:#7d1d1d; color:#fff; border:1px solid #a22828; }
            #poeLoginBtn.logout-state:hover { background:#942424; }
            /* Ensure native select dropdown text is readable on dark theme */
            select.sel-currency, select.sel-time, select.sel-sort, select.sel-rarity, select.sel-type {
                color: var(--text-primary);
            }
            select.sel-currency option,
            select.sel-time option,
            select.sel-sort option,
            select.sel-rarity option,
            select.sel-type option { background: var(--bg-tertiary); color: var(--text-primary); }

            #noFeaturesPlaceholder {
                display: none;
                flex: 1 1 auto;
                min-height: 0;
                align-items: center;
                justify-content: center;
                text-align: center;
                padding: 24px;
                color: var(--text-secondary);
            }
            #noFeaturesPlaceholder .no-features-card {
                background: var(--bg-secondary);
                border: 1px solid var(--border-color);
                border-radius: 8px;
                padding: 20px 24px;
                max-width: 360px;
                width: 100%;
                box-shadow: 0 12px 30px rgba(0, 0, 0, 0.35);
                display: flex;
                flex-direction: column;
                gap: 8px;
            }
            #noFeaturesPlaceholder .no-features-title {
                font-size: 15px;
                font-weight: 600;
                color: var(--text-primary);
            }
            #noFeaturesPlaceholder .no-features-message {
                font-size: 13px;
                line-height: 1.5;
            }
            body.overlay-no-features #controlPanel,
            body.overlay-no-features #content,
            body.overlay-no-features #craftingPanel,
            body.overlay-no-features #historyContainer,
            body.overlay-no-features #historyHeaderMain,
            body.overlay-no-features #historyHeader {
                display: none !important;
            }
            body.overlay-no-features #noFeaturesPlaceholder {
                display: flex !important;
            }
            body.overlay-no-features #footer {
                justify-content: flex-end !important;
            }
            body.overlay-no-features #footer .tabs {
                display: none !important;
            }
            body.overlay-poe1-mode #noFeaturesPlaceholder .no-features-title {
                color: var(--accent-orange);
            }
            /* PoE1/PoE2 menu item visibility */
            .poe1-only { display: none !important; }
            .poe2-only { display: flex !important; }
            body.overlay-poe1-mode .poe1-only { display: flex !important; }
            body.overlay-poe1-mode .poe2-only { display: none !important; }
        </style>
</head>
<body>
    <!-- App header -->
    <div id="mainHeader" class="header" style="background: var(--bg-secondary); padding: 8px 12px; border-bottom: 1px solid var(--border-color); display:flex; align-items:center; gap:8px; -webkit-app-region: drag; flex: 0 0 auto;">
        <div class="item-info">
            <div class="item-name" id="headerTitle" style="font-weight:600; font-size:14px; user-select:none;">Modifier</div>
            <div class="item-type" id="headerSubtitle" style="font-size:12px; color:var(--text-muted); user-select:none;"></div>
        </div>
        <!-- Modifier info badges (shown on modifiers tab) -->
        <div id="modifierHeaderInfo" style="display:none; margin-left:8px; -webkit-app-region: no-drag;"></div>
        <!-- Merchant header (shown only on History tab) -->
        <div id="historyHeaderMain" style="flex:1 1 auto; min-width:0; align-items:center; gap:8px; justify-content:space-between; display:flex; -webkit-app-region: drag;">
            <div style="display:flex; align-items:center; gap:6px; flex-wrap:wrap;">
                <button id="poeLoginBtn" class="pin-btn login-state" style="-webkit-app-region: no-drag;" title="Login to pathofexile.com">Login</button>
                <button id="historyRefreshBtn" class="pin-btn" style="-webkit-app-region: no-drag;" title="Refresh history">Refresh</button>
                <button id="historyPopoutBtn" class="pin-btn" style="-webkit-app-region: no-drag;" title="Pop out history">ðŸ“Œ</button>
                <span id="historyInfoBadge" class="price-badge" style="display:none;">Info</span>
            </div>
            <div style="display:flex; align-items:center; gap:8px; flex-wrap:wrap;">
                <div id="historyTotals" style="display:flex; gap:6px; flex-wrap:nowrap; align-items:center; overflow:hidden;"></div>
                <span id="historyTradeCount" style="color:var(--text-secondary); font-size:11px;"></span>
            </div>
        </div>
        <div class="header-actions" style="display:flex; align-items:center; gap:6px; margin-left:auto; -webkit-app-region: no-drag; user-select:none;">
            <div id="whittlingInfo" style="display:none; margin-right:6px; -webkit-app-region: no-drag;"></div>
            <button id="pinBtn" class="pin-btn" title="Pin overlay on top">Pin</button>
            <button id="closeBtn" class="close-btn" title="Close overlay">Ã—</button>
        </div>
    </div>
    <div id="app" style="display:flex; flex-direction:column; flex:1 1 auto; min-height:0;">
    <div id="controlPanel" class="control-panel" style="-webkit-app-region: no-drag;">
        <div class="cp-left" style="display:flex; align-items:center; gap:6px; flex:0 0 auto;">
            <label class="cp-label" style="font-size:11px; color:var(--text-secondary);">Category</label>
            <div id="categorySelectWrapper" class="category-select-wrapper" style="min-width:140px;">
                <button id="categorySelectDisplay" class="cp-select category-select-display" type="button" aria-haspopup="listbox" aria-expanded="false">
                    <span id="categorySelectIcon" class="category-select-display-icon" aria-hidden="true"></span>
                    <span id="categorySelectLabel" class="category-select-display-label">Select category...</span>
                    <span class="category-select-display-caret" aria-hidden="true">â–¾</span>
                </button>
                <div id="categorySelectMenu" class="category-select-menu" role="listbox" aria-hidden="true"></div>
                <select id="categorySelect" class="cp-select category-select-native" aria-hidden="true" tabindex="-1"></select>
            </div>
        </div>
        <div id="searchInputWrap" class="cp-search-wrap" style="flex:0 0 auto;">
            <input id="search-input" class="cp-search" type="text" placeholder="Search..." style="width:150px;" />
        </div>
        <div id="ilvlControls" style="display:flex; align-items:center; gap:4px; flex:0 0 auto; white-space:nowrap;">
            <label style="font-size:11px; color:var(--text-secondary);">iLvl</label>
            <input id="ilvl-min" type="number" min="0" placeholder="min" style="width:50px; padding:3px 4px; background:var(--bg-tertiary); border:1px solid var(--border-color); border-radius:4px; color:var(--text-primary); font-size:11px;" />
            <span style="color:var(--text-secondary); font-size:11px;">-</span>
            <input id="ilvl-max" type="number" min="0" placeholder="max" style="width:50px; padding:3px 4px; background:var(--bg-tertiary); border:1px solid var(--border-color); border-radius:4px; color:var(--text-primary); font-size:11px;" />
        </div>
        <div id="domainFilters" class="cp-filters" style="display:flex; align-items:center; gap:4px; flex:0 0 auto; white-space:nowrap;">
            <span class="cp-filters-label" style="font-size:11px; color:var(--text-secondary);">Show:</span>
            <!-- Domain toggle buttons will be dynamically rendered here -->
        </div>
        <button id="clearFilters" class="pin-btn cp-clear" style="margin-left:auto; flex:0 0 auto;">Clear</button>
        </div>
    <div id="content" style="flex:1 1 auto; overflow:auto; padding:16px 12px 12px 12px;">
            <div class="no-mods">Pick a category from the dropdown to load modifiers.</div>
        </div>
    <div id="craftingPanel" style="display:none; position:relative; flex:1 1 auto; overflow:auto; padding:16px 12px 12px 12px;"></div>
        <!-- History view container (hidden by default, toggled by Merchant History tab) -->
    <!-- History container (normal flow, visibility controlled by data-view) -->
    <div id="historyContainer" style="display:none; flex:1 1 auto; overflow:hidden;">
            <div id="historyLeaguePrompt" class="history-league-prompt" style="display:none;">
                <div id="historyLeaguePromptMessage" class="history-league-prompt-message"></div>
                <div id="historyLeaguePromptButtons" class="history-league-prompt-buttons"></div>
                <button id="historyLeaguePromptDismiss" type="button" class="history-league-prompt-dismiss">Not now</button>
            </div>
            <!-- History header/filters -->
                        <div id="historyHeader" style="display:flex; flex-direction:column; gap:2px; padding:4px 8px 2px 8px; border-bottom:1px solid var(--border-color); background: var(--bg-secondary); -webkit-app-region: no-drag;">
                            <div id="historyHeaderRow2" style="display:flex; flex-direction:row; align-items:center; gap:8px; flex-wrap:nowrap; overflow:hidden;">
                                <div class="fgrp grp-currency" style="display:flex; align-items:center; gap:4px;">
                                    <label style="color:var(--text-secondary); font-size:11px;">Currency:</label>
                                      <select id="histCurrency" class="sel-currency" style="padding:3px 6px; background:var(--bg-tertiary); border:1px solid var(--border-color); border-radius:4px; color:var(--text-primary); font-size:11px; appearance:none;">
                                        <option value="">All</option>
                                        <option value="exalted">Exalted</option>
                                        <option value="divine">Divine</option>
                                        <option value="annul">Annul</option>
                                        <option value="chaos">Chaos</option>
                                        <option value="regal">Regal</option>
                                    </select>
                                    <div id="histAmountRange" style="display:flex; align-items:center; gap:4px;">
                                        <input id="histMinValue" type="number" min="0" placeholder="min" style="width:60px; padding:3px 4px; background:var(--bg-tertiary); border:1px solid var(--border-color); border-radius:4px; color:var(--text-primary); font-size:11px;" />
                                        <span style="color:var(--text-secondary); font-size:11px;">-</span>
                                        <input id="histMaxValue" type="number" min="0" placeholder="max" style="width:60px; padding:3px 4px; background:var(--bg-tertiary); border:1px solid var(--border-color); border-radius:4px; color:var(--text-primary); font-size:11px;" />
                                    </div>
                                </div>
                                <div class="fgrp grp-time" style="display:flex; align-items:center; gap:4px;">
                                    <label style="color:var(--text-secondary); font-size:11px;">Time:</label>
                                      <select id="histTimeframe" class="sel-time" style="padding:3px 6px; background:var(--bg-tertiary); border:1px solid var(--border-color); border-radius:4px; color:var(--text-primary); font-size:11px; appearance:none;">
                                        <option value="all" selected>All</option>
                                        <option value="today">Today</option>
                                        <option value="yesterday">Yesterday</option>
                                        <option value="7d">7D</option>
                                        <option value="14d">14D</option>
                                        <option value="30d">30D</option>
                                    </select>
                                </div>
                                <div class="fgrp grp-sort" style="display:flex; align-items:center; gap:4px;">
                                    <label style="color:var(--text-secondary); font-size:11px;">Sort:</label>
                                      <select id="histSort" class="sel-sort" style="padding:3px 6px; background:var(--bg-tertiary); border:1px solid var(--border-color); border-radius:4px; color:var(--text-primary); font-size:11px; appearance:none;">
                                        <option value="newest">Newest</option>
                                        <option value="oldest">Oldest</option>
                                        <option value="divine-desc">Highest Divine</option>
                                        <option value="divine-asc">Lowest Divine</option>
                                        <option value="exalted-desc">Highest Exalted</option>
                                        <option value="exalted-asc">Lowest Exalted</option>
                                        <option value="chaos-desc">Highest Chaos</option>
                                        <option value="chaos-asc">Lowest Chaos</option>
                                        <option value="regal-desc">Highest Regal</option>
                                        <option value="regal-asc">Lowest Regal</option>
                                    </select>
                                </div>
                                <div class="fgrp grp-rarity" style="display:flex; align-items:center; gap:4px;">
                                    <label style="color:var(--text-secondary); font-size:11px;">Rarity:</label>
                                      <select id="histRarity" class="sel-rarity" style="padding:3px 6px; background:var(--bg-tertiary); border:1px solid var(--border-color); border-radius:4px; color:var(--text-primary); font-size:11px; appearance:none;">
                                        <option value="">All</option>
                                        <option value="Normal">Normal</option>
                                        <option value="Magic">Magic</option>
                                        <option value="Rare">Rare</option>
                                        <option value="Unique">Unique</option>
                                        <option value="Foil">Foil</option>
                                    </select>
                                </div>
                                <div class="fgrp grp-type" style="display:flex; align-items:center; gap:4px;">
                                    <label style="color:var(--text-secondary); font-size:11px;">Type:</label>
                                      <select id="histCategory" class="sel-type" style="padding:3px 6px; background:var(--bg-tertiary); border:1px solid var(--border-color); border-radius:4px; color:var(--text-primary); font-size:11px; appearance:none;">
                                        <option value="">All</option>
                                        <option>Helmets</option>
                                        <option>Body Armours</option>
                                        <option>Gloves</option>
                                        <option>Boots</option>
                                        <option>Offhand</option>
                                        <option>Rings</option>
                                        <option>Amulets</option>
                                        <option>Belts</option>
                                        <option>Weapons</option>
                                        <option>Jewels</option>
                                        <option>Other</option>
                                    </select>
                                </div>
                                <div class="fgrp grp-search" style="display:flex; align-items:center; gap:4px;">
                                    <input id="histSearch" class="inp-search" type="text" placeholder="Search items..." style="width:220px; padding:3px 8px; background:var(--bg-tertiary); border:1px solid var(--border-color); border-radius:6px; color:var(--text-primary); font-size:11px;" />
                                </div>
                            </div>
                            <div id="historyActiveFilters" style="display:flex; gap:6px; flex-wrap:wrap;"></div>
                        </div>
            <!-- History body (list + details + chart) -->
            <div id="historyBody" style="display:flex; flex:1 1 auto; min-height:0;">
            <!-- Left list -->
            <div id="historyList" style="flex: 0 0 55%; border-right:1px solid var(--border-color); overflow-y:auto; min-height:0;">
                <!-- rows injected here -->
            </div>
            <!-- Right details -->
            <div id="historyRight" style="flex: 1 1 auto; display:flex; flex-direction:column; overflow:hidden; min-height:0;">
                <div id="historyDetail" style="flex: 0 0 auto; overflow-y:visible; padding: 10px; min-height:0;">
                    <div class="no-mods">Select a trade to see item details</div>
                </div>
                <div id="historyChartWrap" class="history-chart-wrap">
                    <div class="history-chart-controls" id="historyChartHeader">
                        <div class="history-chart-controls-left">
                            <button id="chartCollapseBtn" class="chart-inline-btn" title="Collapse chart">â–¼</button>
                            <button id="chartExpandBtn" class="chart-inline-btn" title="Expand chart to take full space">â–²</button>
                            <div class="history-chart-title">Totals over time</div>
                        </div>
                        <div id="chartLegend" class="chart-legend" data-min-lock="2">
                            <span id="chartCur-divine" class="chart-cur active" data-cur="divine" data-priority="1" data-lock="1"><span class="sw" style="background:#d4af37;"></span> Divine</span>
                            <span id="chartCur-exalted" class="chart-cur" data-cur="exalted" data-priority="2" data-lock="1"><span class="sw" style="background:#3f6aa1;"></span> Exalted</span>
                            <span id="chartCur-annul" class="chart-cur" data-cur="annul" data-priority="3"><span class="sw" style="background:#7b40b3;"></span> Annul</span>
                            <span id="chartCur-chaos" class="chart-cur" data-cur="chaos" data-priority="4"><span class="sw" style="background:#4a6a35;"></span> Chaos</span>
                            <span id="chartCur-regal" class="chart-cur" data-cur="regal" data-priority="5"><span class="sw" style="background:#6b4a28;"></span> Regal</span>
                            <button id="chartLegendMore" class="chart-legend-more" type="button" aria-expanded="false" hidden>+0</button>
                        </div>
                    </div>
                    <div id="historyChartBody" class="history-chart-body">
                        <canvas id="historyChart" height="150"></canvas>
                    </div>
                </div>
            </div>
            </div>
        </div>
    </div>
    </div>
    <div id="noFeaturesPlaceholder">
        <div class="no-features-card">
            <div class="no-features-title" id="noFeaturesTitle">Overlay mode limited</div>
            <div class="no-features-message" id="noFeaturesMessage">Overlay features are currently unavailable.</div>
        </div>
    </div>

    <!-- Footer with tabs and resize handle -->
    <div class="footer" id="footer" style="background: var(--bg-secondary); border-top: 1px solid var(--border-color); padding: 4px 8px; display: flex; align-items: center; justify-content: space-between; -webkit-app-region: drag; flex: 0 0 auto;">
        <div class="tabs" style="display: flex; gap: 8px; -webkit-app-region: no-drag;">
            <button id="tabModifier" class="tab active" style="background: var(--accent-blue); color: #fff; border: 1px solid var(--accent-blue); border-radius: 4px; padding: 3px 8px; font-size: 12px; display:inline-flex; align-items:center; gap:4px;">
                <span class="menu-icon" aria-hidden="true">
                    <svg viewBox="0 0 24 24" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <rect x="3" y="3" width="7" height="7"></rect>
                        <rect x="14" y="3" width="7" height="7"></rect>
                        <rect x="14" y="14" width="7" height="7"></rect>
                        <rect x="3" y="14" width="7" height="7"></rect>
                    </svg>
                </span>
                <span>Modifier</span>
            </button>
            <div class="tab" id="craftingTab" style="position:relative; background: var(--bg-tertiary); color: var(--text-primary); border: 1px solid var(--border-color); border-radius: 4px; padding: 3px 8px; font-size: 12px; cursor:pointer; display:inline-flex; align-items:center; gap:4px;">
                <span class="menu-icon" aria-hidden="true">
                    <svg viewBox="0 0 24 24" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M12 2l3 7h7l-5.5 4.1L18 21l-6-4-6 4 1.5-7.9L2 9h7z" />
                    </svg>
                </span>
                <span>Crafting â–¾</span>
                <div id="craftingMenu" style="display:none; position:absolute; left:0; bottom:100%; transform: translateY(-4px); background: var(--bg-secondary); border:1px solid var(--border-color); border-radius:4px; min-width:160px; box-shadow:0 2px 6px rgba(0,0,0,0.4); z-index:200;">
                    <div class="crafting-menu-item poe2-only" data-action="liquid-emotions" style="padding:6px 8px; font-size:12px; white-space:nowrap; cursor:pointer; display:flex; align-items:center; gap:6px;">
                        <span class="menu-icon"><svg viewBox="0 0 24 24" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 2C9 7 7 9.5 7 13a5 5 0 0010 0c0-3.5-2-6-5-11z"/></svg></span>
                        <span>Liquid Emotions</span>
                    </div>
                    <div class="crafting-menu-item poe2-only" data-action="annoints" style="padding:6px 8px; font-size:12px; white-space:nowrap; cursor:pointer; display:flex; align-items:center; gap:6px;">
                        <span class="menu-icon"><svg viewBox="0 0 24 24" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 20l4-9 4 4 8-12" /><path d="M2 4h6"/></svg></span>
                        <span>Annoints</span>
                    </div>
                    <div class="crafting-menu-item poe2-only" data-action="essences" style="padding:6px 8px; font-size:12px; white-space:nowrap; cursor:pointer; display:flex; align-items:center; gap:6px;">
                        <span class="menu-icon"><svg viewBox="0 0 24 24" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 2l6 6-6 14-6-14 6-6z"/></svg></span>
                        <span>Essences</span>
                    </div>
                    <div class="crafting-menu-item poe2-only" data-action="omens" style="padding:6px 8px; font-size:12px; white-space:nowrap; cursor:pointer; display:flex; align-items:center; gap:6px;">
                        <span class="menu-icon"><svg viewBox="0 0 24 24" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="4" /><path d="M2 12h2M20 12h2M12 2v2M12 20v2M4.9 4.9l1.4 1.4M17.7 17.7l1.4 1.4M19.1 4.9l-1.4 1.4M6.3 17.7l-1.4 1.4"/></svg></span>
                        <span>Omens</span>
                    </div>
                    <div class="crafting-menu-item poe2-only" data-action="currency" style="padding:6px 8px; font-size:12px; white-space:nowrap; cursor:pointer; display:flex; align-items:center; gap:6px;">
                        <span class="menu-icon"><svg viewBox="0 0 24 24" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="8" cy="12" r="3"/><circle cx="16" cy="12" r="3"/><path d="M8 9V5m0 14v-4m8-6V5m0 14v-4"/></svg></span>
                        <span>Currency</span>
                    </div>
                    <div class="crafting-menu-item poe2-only" data-action="catalysts" style="padding:6px 8px; font-size:12px; white-space:nowrap; cursor:pointer; display:flex; align-items:center; gap:6px;">
                        <span class="menu-icon"><svg viewBox="0 0 24 24" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 2l3 5-3 5-3-5 3-5z"/><path d="M5 19h14"/><path d="M5 15h14"/></svg></span>
                        <span>Catalysts</span>
                    </div>
                    <div class="crafting-menu-item poe2-only" data-action="socketables" style="padding:6px 8px; font-size:12px; white-space:nowrap; cursor:pointer; display:flex; align-items:center; gap:6px;">
                        <span class="menu-icon"><svg viewBox="0 0 24 24" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="8" width="7" height="8" rx="1"/><rect x="14" y="5" width="7" height="14" rx="1"/></svg></span>
                        <span>Socketables</span>
                    </div>
                    <!-- PoE1 Crafting Items -->
                    <div class="crafting-menu-item poe1-only" data-action="poe1-scarabs" style="padding:6px 8px; font-size:12px; white-space:nowrap; cursor:pointer; display:flex; align-items:center; gap:6px;">
                        <span class="menu-icon"><svg viewBox="0 0 24 24" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 2c-1.5 1.5-3 3.5-3 6 0 1.5.5 3 1.5 4l-4 4c-1 1-1.5 2.5-1.5 4s.5 3 1.5 4l4-4c1 1 2.5 1.5 4 1.5 2.5 0 4.5-1.5 6-3L12 2z"/></svg></span>
                        <span>Scarabs</span>
                    </div>
                    <div class="crafting-menu-item poe1-only" data-action="poe1-runegrafts" style="padding:6px 8px; font-size:12px; white-space:nowrap; cursor:pointer; display:flex; align-items:center; gap:6px;">
                        <span class="menu-icon"><svg viewBox="0 0 24 24" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 3l7 4v10l-7 4-7-4V7z"/><path d="M9 8l3 2 3-2"/><path d="M9 12l3 2 3-2"/></svg></span>
                        <span>Runegrafts</span>
                    </div>
                    <div class="crafting-menu-item poe1-only" data-action="poe1-horticrafting" style="padding:6px 8px; font-size:12px; white-space:nowrap; cursor:pointer; display:flex; align-items:center; gap:6px;">
                        <span class="menu-icon"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 2C7.5 4 5 7.8 5 12.5A6.5 6.5 0 0011.5 19c4.7 0 7.5-3.5 7.5-7.5C19 7 16 4 12 2z"/><path d="M7 18c1.5-2.5 4-4 7-4"/></svg></span>
                        <span>Horticrafting</span>
                    </div>
                    <div class="crafting-menu-item poe1-only" data-action="poe1-bestiary" style="padding:6px 8px; font-size:12px; white-space:nowrap; cursor:pointer; display:flex; align-items:center; gap:6px;">
                        <span class="menu-icon"><svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 21c3 0 5-2 5-4s-2-3-5-3-5 1-5 3 2 4 5 4z"/><circle cx="7" cy="9" r="2" fill="currentColor" stroke="none"/><circle cx="12" cy="7" r="2" fill="currentColor" stroke="none"/><circle cx="17" cy="9" r="2" fill="currentColor" stroke="none"/><circle cx="9" cy="13" r="1.8" fill="currentColor" stroke="none"/><circle cx="15" cy="13" r="1.8" fill="currentColor" stroke="none"/></svg></span>
                        <span>Bestiary</span>
                    </div>
                    <div class="crafting-menu-item poe1-only" data-action="poe1-currency" style="padding:6px 8px; font-size:12px; white-space:nowrap; cursor:pointer; display:flex; align-items:center; gap:6px;">
                        <span class="menu-icon"><svg viewBox="0 0 24 24" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="8" cy="12" r="3"/><circle cx="16" cy="12" r="3"/><path d="M8 9V5m0 14v-4m8-6V5m0 14v-4"/></svg></span>
                        <span>Currency</span>
                    </div>
                    <div class="crafting-menu-item poe1-only" data-action="poe1-essences" style="padding:6px 8px; font-size:12px; white-space:nowrap; cursor:pointer; display:flex; align-items:center; gap:6px;">
                        <span class="menu-icon"><svg viewBox="0 0 24 24" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 2l6 6-6 14-6-14 6-6z"/></svg></span>
                        <span>Essences</span>
                    </div>
                    <div class="crafting-menu-item poe1-only" data-action="poe1-fossils" style="padding:6px 8px; font-size:12px; white-space:nowrap; cursor:pointer; display:flex; align-items:center; gap:6px;">
                        <span class="menu-icon"><svg viewBox="0 0 24 24" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 12h18M12 3v18M8 8l8 8M16 8l-8 8"/></svg></span>
                        <span>Fossils</span>
                    </div>
                    <div class="crafting-menu-item poe1-only" data-action="poe1-embers" style="padding:6px 8px; font-size:12px; white-space:nowrap; cursor:pointer; display:flex; align-items:center; gap:6px;">
                        <span class="menu-icon"><svg viewBox="0 0 24 24" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 2C9 7 7 9.5 7 13a5 5 0 0010 0c0-3.5-2-6-5-11z"/><path d="M9 16c0 1.5.5 2.5 3 2.5s3-1 3-2.5"/></svg></span>
                        <span>Allflames</span>
                    </div>
                        </div>
            </div>
            <div class="tab" id="characterTab" style="position:relative; background: var(--bg-tertiary); color: var(--text-primary); border: 1px solid var(--border-color); border-radius: 4px; padding: 3px 8px; font-size: 12px; cursor:pointer; display:inline-flex; align-items:center; gap:4px;">
                <span class="menu-icon" aria-hidden="true"><svg viewBox="0 0 24 24" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="7" r="4"/><path d="M5.5 21a6.5 6.5 0 0113 0"/></svg></span>
                <span>Character â–¾</span>
                <div id="characterMenu" style="display:none; position:absolute; left:0; bottom:100%; transform: translateY(-4px); background: var(--bg-secondary); border:1px solid var(--border-color); border-radius:4px; min-width:160px; box-shadow:0 2px 6px rgba(0,0,0,0.4); z-index:250;">
                    <div class="character-menu-item" data-action="quest-passives" style="padding:6px 8px; font-size:12px; white-space:nowrap; cursor:pointer; display:flex; align-items:center; gap:6px;">
                        <span class="menu-icon"><svg viewBox="0 0 24 24" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 4h16v4H4z"/><path d="M4 12h16v8H4z"/></svg></span>
                        <span>Quest Passives</span>
                    </div>
                    <div class="character-menu-item" data-action="keystones" style="padding:6px 8px; font-size:12px; white-space:nowrap; cursor:pointer; display:flex; align-items:center; gap:6px;">
                        <span class="menu-icon"><svg viewBox="0 0 24 24" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 2l7 4v6c0 5-3 8-7 10-4-2-7-5-7-10V6l7-4z"/></svg></span>
                        <span>Keystones</span>
                    </div>
                    <div class="character-menu-item" data-action="asc-passives" style="padding:6px 8px; font-size:12px; white-space:nowrap; cursor:pointer; display:flex; align-items:center; gap:6px;">
                        <span class="menu-icon"><svg viewBox="0 0 24 24" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="3"/><path d="M12 2v4M12 18v4M4.93 4.93l2.83 2.83M16.24 16.24l2.83 2.83M2 12h4M18 12h4M4.93 19.07l2.83-2.83M16.24 7.76l2.83-2.83"/></svg></span>
                        <span>Ascendancy Passives</span>
                    </div>
                    <div class="character-menu-item" data-action="atlas-nodes" style="padding:6px 8px; font-size:12px; white-space:nowrap; cursor:pointer; display:flex; align-items:center; gap:6px;">
                        <span class="menu-icon"><svg viewBox="0 0 24 24" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="3" /><path d="M19.4 15a1.65 1.65 0 00.33 1.82l.06.06a2 2 0 01-2.83 2.83l-.06-.06A1.65 1.65 0 0015 19.4a1.65 1.65 0 00-1.82.33l-.06.06a2 2 0 01-2.83 0l-.06-.06A1.65 1.65 0 008.6 19.4a1.65 1.65 0 00-1.82-.33l-.06.06a2 2 0 01-2.83-2.83l.06-.06A1.65 1.65 0 004.6 15a1.65 1.65 0 00-.33-1.82l-.06-.06a2 2 0 012.83-2.83l.06.06A1.65 1.65 0 008.6 9a1.65 1.65 0 001.82-.33l.06-.06a2 2 0 012.83 0l.06.06A1.65 1.65 0 0015 9a1.65 1.65 0 001.82-.33l.06-.06a2 2 0 012.83 2.83l-.06.06A1.65 1.65 0 0019.4 13c0 .4.16.78.44 1.06z"/></svg></span>
                        <span>Atlas Nodes</span>
                    </div>
                    <div class="character-menu-item" data-action="gems" style="padding:6px 8px; font-size:12px; white-space:nowrap; cursor:pointer; display:flex; align-items:center; gap:6px;">
                        <span class="menu-icon"><svg viewBox="0 0 24 24" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M6 3h12l3 6-9 12L3 9l3-6z"/><path d="M3 9h18"/><path d="M12 3l-3 6 3 12 3-12-3-6z"/></svg></span>
                        <span>Gems</span>
                    </div>
                    <div class="character-menu-item poe1-only" data-action="poe1-divination-cards" style="padding:6px 8px; font-size:12px; white-space:nowrap; cursor:pointer; display:flex; align-items:center; gap:6px;">
                        <span class="menu-icon"><svg viewBox="0 0 24 24" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="4" y="4" width="16" height="16" rx="2"/><path d="M8 10h8M8 14h5"/></svg></span>
                        <span>Divination Cards</span>
                    </div>
                    <div class="character-menu-item poe1-only" data-action="poe1-asc-notables" style="padding:6px 8px; font-size:12px; white-space:nowrap; cursor:pointer; display:flex; align-items:center; gap:6px;">
                        <span class="menu-icon"><svg viewBox="0 0 24 24" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="3"/><path d="M12 2v3M12 19v3M4.22 4.22l2.12 2.12M17.66 17.66l2.12 2.12M2 12h3M19 12h3M4.22 19.78l2.12-2.12M17.66 6.34l2.12-2.12"/></svg></span>
                        <span>Ascendancy Notables</span>
                    </div>
                    <div class="character-menu-item poe1-only" data-action="poe1-anointments" style="padding:6px 8px; font-size:12px; white-space:nowrap; cursor:pointer; display:flex; align-items:center; gap:6px;">
                        <span class="menu-icon"><svg viewBox="0 0 24 24" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 3C9 7 7 10.5 7 13a5 5 0 0010 0c0-2.5-2-6-5-10z"/><path d="M12 11v4"/><path d="M10 13h4"/></svg></span>
                        <span>Anointments</span>
                    </div>
                    <div class="character-menu-item poe1-only" data-action="poe1-tattoos" style="padding:6px 8px; font-size:12px; white-space:nowrap; cursor:pointer; display:flex; align-items:center; gap:6px;">
                        <span class="menu-icon"><svg viewBox="0 0 24 24" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 2L2 7l10 5 10-5-10-5z"/><path d="M2 17l10 5 10-5M2 12l10 5 10-5"/></svg></span>
                        <span>Tattoos</span>
                    </div>
                    <div class="character-menu-item poe1-only" data-action="poe1-gems-list" style="padding:6px 8px; font-size:12px; white-space:nowrap; cursor:pointer; display:flex; align-items:center; gap:6px;">
                        <span class="menu-icon"><svg viewBox="0 0 24 24" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M6 3h12l3 6-9 12L3 9l3-6z"/><path d="M3 9h18"/><path d="M12 3l-3 6 3 12 3-12-3-6z"/></svg></span>
                        <span>Gems</span>
                    </div>
                    <div class="character-menu-item" data-action="glossar" style="padding:6px 8px; font-size:12px; white-space:nowrap; cursor:pointer; display:flex; align-items:center; gap:6px;">
                        <span class="menu-icon"><svg viewBox="0 0 24 24" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 19.5A2.5 2.5 0 016.5 17H20"/><path d="M4 4.5A2.5 2.5 0 016.5 7H20"/><path d="M6.5 7v10"/><path d="M12 7v10"/><path d="M17.5 7v10"/></svg></span>
                        <span>Glossar</span>
                    </div>
                </div>
            </div>
            <div class="tab" id="itemsTab" style="position:relative; background: var(--bg-tertiary); color: var(--text-primary); border: 1px solid var(--border-color); border-radius: 4px; padding: 3px 8px; font-size: 12px; cursor:pointer; display:inline-flex; align-items:center; gap:4px;">
                <span class="menu-icon" aria-hidden="true"><svg viewBox="0 0 24 24" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="7" height="7"/><rect x="14" y="3" width="7" height="7"/><rect x="14" y="14" width="7" height="7"/><rect x="3" y="14" width="7" height="7"/></svg></span>
                <span class="tab-label">Items â–¾</span>
                <div id="itemsMenu" style="display:none; position:absolute; left:0; bottom:100%; transform: translateY(-4px); background:var(--bg-secondary); border:1px solid var(--border-color); border-radius:4px; padding:4px; z-index:300; min-width:140px; box-shadow:0 4px 14px rgba(0,0,0,0.5);">
                    <div class="items-menu-item" data-action="uniques" style="padding:6px 8px; font-size:12px; white-space:nowrap; cursor:pointer; display:flex; align-items:center; gap:6px;">
                        <span class="menu-icon"><svg viewBox="0 0 24 24" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 2l4 4-4 4-4-4 4-4z"/><path d="M12 14l4 4-4 4-4-4 4-4z"/><path d="M2 12l4-4 4 4-4 4-4-4z"/><path d="M14 12l4-4 4 4-4 4-4-4z"/></svg></span>
                        <span>Uniques</span>
                    </div>
                    <div class="items-menu-item" data-action="bases" style="padding:6px 8px; font-size:12px; white-space:nowrap; cursor:pointer; display:flex; align-items:center; gap:6px;">
                        <span class="menu-icon"><svg viewBox="0 0 24 24" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="4" y="4" width="16" height="16" rx="2"/></svg></span>
                        <span>Bases</span>
                    </div>
                </div>
            </div>
            <div class="tab" id="toolsTab" style="position:relative; background: var(--bg-tertiary); color: var(--text-primary); border: 1px solid var(--border-color); border-radius: 4px; padding: 3px 8px; font-size: 12px; cursor:pointer; display:inline-flex; align-items:center; gap:4px;">
                <span class="menu-icon" aria-hidden="true">
                    <!-- Tools icon â€“ CC Attribution, atomicons (https://atomicons.com/) -->
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="miter">
                        <path d="M22 8.5A6.5 6.5 0 0 1 15.5 15a6.38 6.38 0 0 1-2-.3L6.62 21.62 2.38 17.38 9.3 10.46a6.38 6.38 0 0 1-.3-2 6.49 6.49 0 0 1 9.34-5.84L14 7l3 3 4.34-4.34A6.45 6.45 0 0 1 22 8.5Z"/>
                    </svg>
                </span>
                <span>Tools â–¾</span>
                <div id="toolsMenu" style="display:none; position:absolute; left:0; bottom:100%; transform: translateY(-4px); background:var(--bg-secondary); border:1px solid var(--border-color); border-radius:4px; padding:4px; z-index:320; min-width:140px; box-shadow:0 4px 14px rgba(0,0,0,0.55);">
                    <div class="tools-menu-item poe2-only" data-action="regex" style="padding:6px 8px; font-size:12px; white-space:nowrap; cursor:pointer; display:flex; align-items:center; gap:6px;">
                        <span class="menu-icon"><svg viewBox="0 0 24 24" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M17 3l4 4-4 4"/><path d="M3 7h18"/><path d="M7 21l-4-4 4-4"/><path d="M21 17H3"/></svg></span>
                        <span>Regex Builder</span>
                    </div>
                    <div class="tools-menu-item poe1-only" data-action="poe1-regex" style="padding:6px 8px; font-size:12px; white-space:nowrap; cursor:pointer; display:flex; align-items:center; gap:6px;">
                        <span class="menu-icon"><svg viewBox="0 0 24 24" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 4h16v4H4z"/><path d="M4 12h16v4H4z"/><path d="M4 20h16"/></svg></span>
                        <span>Map Regex</span>
                    </div>
                    <div class="tools-menu-item poe1-only" data-action="poe1-vorici" style="padding:6px 8px; font-size:12px; white-space:nowrap; cursor:pointer; display:flex; align-items:center; gap:6px;">
                        <span class="menu-icon"><svg viewBox="0 0 24 24" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="3"/><path d="M19.4 15a1.65 1.65 0 00.33 1.82l.06.06a2 2 0 01-2.83 2.83l-.06-.06A1.65 1.65 0 0015 19.4a1.65 1.65 0 00-1.82.33l-.06.06a2 2 0 01-2.83 0l-.06-.06A1.65 1.65 0 008.6 19.4a1.65 1.65 0 00-1.82-.33l-.06.06a2 2 0 01-2.83-2.83l.06-.06A1.65 1.65 0 004.6 15a1.65 1.65 0 00-.33-1.82l-.06-.06a2 2 0 012.83-2.83l.06.06A1.65 1.65 0 008.6 9a1.65 1.65 0 001.82-.33l.06-.06a2 2 0 012.83 0l.06.06A1.65 1.65 0 0015 9a1.65 1.65 0 001.82-.33l.06-.06a2 2 0 012.83 2.83l-.06.06A1.65 1.65 0 0019.4 13c0 .4.16.78.44 1.06z"/></svg></span>
                        <span>Vorici Calculator</span>
                    </div>
                </div>
            </div>
            <button id="tabHistory" class="tab" style="background: var(--bg-tertiary); color: var(--text-primary); border: 1px solid var(--border-color); border-radius: 4px; padding: 3px 8px; font-size: 12px; display:inline-flex; align-items:center; gap:4px;">
                <span class="menu-icon" aria-hidden="true"><svg viewBox="0 0 24 24" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 3h18v4H3z"/><path d="M3 11h18v10H3z"/><path d="M8 7v14"/><path d="M16 7v14"/></svg></span>
                <span>Merchant History</span>
            </button>
        </div>
        <div class="footer-actions" style="display:flex; align-items:center; gap:6px; -webkit-app-region: no-drag;">
            <button id="updateBadge" class="pin-btn" style="display:none; background: var(--accent-orange); border: 1px solid var(--accent-orange); color: #fff; border-radius: 4px; padding: 3px 8px; font-size: 11px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.2px;">
                New Update
            </button>
            <button id="settingsBtn" class="pin-btn" style="width: 32px; height: 26px; display:flex; align-items:center; justify-content:center; padding: 0;" title="Open settings" aria-label="Open settings">
                <!-- Settings cog icon â€“ Public Domain, Significa Labs (https://significa.co/labs/) -->
                <svg width="18" height="18" viewBox="0 0 24 24" fill="none" aria-hidden="true" xmlns="http://www.w3.org/2000/svg">
                    <g transform="translate(2 3)" stroke="currentColor" stroke-width="1.5" stroke-miterlimit="10">
                        <circle cx="2.5" cy="2.5" r="2.5" transform="translate(7.5 6.5)" fill="none"></circle>
                        <path d="M4.452,16.794l.087-3.249-3.249.087A9.078,9.078,0,0,1,.276,11.185l2.36-2.236L.276,6.712A9.078,9.078,0,0,1,1.29,4.265l3.249.087L4.452,1.1A9.078,9.078,0,0,1,6.9.089l2.236,2.36L11.372.089A9.078,9.078,0,0,1,13.82,1.1l-.087,3.249,3.249-.087A9.081,9.081,0,0,1,18,6.712l-2.36,2.237L18,11.185a9.081,9.081,0,0,1-1.015,2.447l-3.249-.087.087,3.249a9.078,9.078,0,0,1-2.448,1.015l-2.236-2.36L6.9,17.809A9.078,9.078,0,0,1,4.452,16.794Z" transform="translate(0.864 0.051)" fill="none"></path>
                    </g>
                </svg>
            </button>
        </div>
    </div>

    <script>

    // Query commonly used elements (guard undefined usage)
    const tabMod = document.getElementById('tabModifier');
    const tabHist = document.getElementById('tabHistory');
    const craftingTab = document.getElementById('craftingTab');
    const craftingMenu = document.getElementById('craftingMenu');
    const characterTab = document.getElementById('characterTab');
    const characterMenu = document.getElementById('characterMenu');
    const itemsTab = document.getElementById('itemsTab');
    const itemsMenu = document.getElementById('itemsMenu');
    const toolsTab = document.getElementById('toolsTab');
    const toolsMenu = document.getElementById('toolsMenu');
    const historyHeader = document.getElementById('historyHeader') || null;
    const historyHeaderMain = document.getElementById('historyHeaderMain') || null;
    const filtersBar = document.getElementById('filtersBar') || null;
    const contentMod = document.getElementById('content');
    const contentHist = document.getElementById('historyContainer') || document.createElement('div');
    const loginBtn = document.getElementById('poeLoginBtn');
    const refreshBtn = document.getElementById('historyRefreshBtn');
    const pinBtn = document.getElementById('pinBtn');
    const closeBtn = document.getElementById('closeBtn');
    const headerTitleEl = document.getElementById('headerTitle');
    const headerSubtitleEl = document.getElementById('headerSubtitle');
    const settingsBtn = document.getElementById('settingsBtn');
    const updateBadgeBtn = document.getElementById('updateBadge');
    const noFeaturesRoot = document.getElementById('noFeaturesPlaceholder');
    const noFeaturesTitleEl = document.getElementById('noFeaturesTitle');
    const noFeaturesMessageEl = document.getElementById('noFeaturesMessage');

    const LAST_CONTEXT_KEY = 'xilehud:last-view-context';
    let firstSelectableCategory = null;
    let categoryDropdownFilter = '';

    const UPDATE_RELEASE_URL = 'https://github.com/XileHUD/poe_overlay/releases/latest';
    let startupUpdateCheckTriggered = false;
    let overlayVersionMode = 'poe2';
    window.__overlayVersionMode = overlayVersionMode;
    let pendingOverlayVersionMode = null;
    let overlayHasAnyFeatures = true;

    function showUpdateBadge(info) {
        if (!updateBadgeBtn) return;
        updateBadgeBtn.style.display = 'inline-flex';
        updateBadgeBtn.dataset.version = info?.version ? String(info.version) : '';
        const normalized = info?.version ? String(info.version).replace(/^v/i, '') : '';
        const message = info?.message || 'A new update is available. Click to open the latest release.';
        updateBadgeBtn.title = normalized ? `${message}\n(v${normalized})` : message;
    }

    function hideUpdateBadge() {
        if (!updateBadgeBtn) return;
        updateBadgeBtn.style.display = 'none';
        delete updateBadgeBtn.dataset.version;
        updateBadgeBtn.title = '';
    }

    async function triggerStartupUpdateCheck() {
        if (startupUpdateCheckTriggered) return;
        startupUpdateCheckTriggered = true;
        if (!window.electronAPI || typeof window.electronAPI.checkUpdates !== 'function') return;
        try {
            const result = await window.electronAPI.checkUpdates();
            if (result && typeof result === 'object' && result.available) {
                showUpdateBadge(result);
            } else {
                hideUpdateBadge();
            }
        } catch {
            hideUpdateBadge();
        }
    }

    function loadLastContext() {
        try {
            const stored = window.localStorage?.getItem(LAST_CONTEXT_KEY);
            if (!stored) return { view: null, action: null, category: null };
            const parsed = JSON.parse(stored);
            return {
                view: parsed?.view || null,
                action: parsed?.action || null,
                category: parsed?.category || null
            };
        } catch {
            return { view: null, action: null, category: null };
        }
    }

    function updateNoFeaturesPlaceholder(title, message) {
        if (!noFeaturesRoot) return;
        if (noFeaturesTitleEl) noFeaturesTitleEl.textContent = title || '';
        if (noFeaturesMessageEl) noFeaturesMessageEl.textContent = message || '';
    }

    function applyOverlayVersionMode(mode) {
        const normalized = mode === 'poe1' ? 'poe1' : 'poe2';
        overlayVersionMode = normalized;
        window.__overlayVersionMode = normalized;
        try { window.OverlayModifiers?.setOverlayVersionMode?.(normalized); } catch {}
        
        // Render version-specific domain toggles
        renderDomainToggles();
        
        // PoE1 mode now has modifiers feature enabled
        if (normalized === 'poe1') {
            document.body.classList.add('overlay-poe1-mode');
            document.body.classList.remove('overlay-no-features');
            setHeader('Path of Exile 1', 'Modifiers');
            const whittlingInfo = document.getElementById('whittlingInfo');
            if (whittlingInfo) {
                whittlingInfo.innerHTML = '';
                whittlingInfo.setAttribute('style', 'display:none; margin-right:6px; -webkit-app-region: no-drag;');
            }
            return;
        }
        
        document.body.classList.remove('overlay-poe1-mode');
        if (!overlayHasAnyFeatures) {
            document.body.classList.add('overlay-no-features');
            updateNoFeaturesPlaceholder('Overlay features disabled', 'Enable overlay features from Settings to re-enable the Modifier, Crafting, or History views.');
        } else {
            document.body.classList.remove('overlay-no-features');
            updateNoFeaturesPlaceholder('', '');
        }
    }

    try {
        window.electronAPI?.onOverlayVersionMode?.((mode) => {
            const normalized = mode === 'poe1' ? 'poe1' : 'poe2';
            overlayVersionMode = normalized;
            window.__overlayVersionMode = normalized;
            try { window.OverlayModifiers?.setOverlayVersionMode?.(normalized); } catch {}
            if (document.readyState === 'loading') {
                pendingOverlayVersionMode = normalized;
                return;
            }
            applyOverlayVersionMode(normalized);
        });
    } catch {}

    let lastContext = loadLastContext();
    let activeView = 'modifiers';

    function saveLastContext() {
        try {
            window.localStorage?.setItem(LAST_CONTEXT_KEY, JSON.stringify(lastContext));
        } catch {}
    }

    function updateLastContext(update) {
        if (!update) return;
        lastContext = { ...lastContext, ...update };
        saveLastContext();
    }

    function markModifiersCategory(cat) {
        if (!cat) return;
        updateLastContext({ view: 'modifiers', category: cat, action: `modifiers:${cat}` });
    }

    function markCraftingAction(actionKey) {
        if (!actionKey) return;
        updateLastContext({ view: 'crafting', action: `crafting:${actionKey}` });
    }

    // ===== Domain Toggle Configuration (mirrors main process config) =====
    const POE2_TOGGLES = [
        { id: 'toggleAll', label: 'All', domain: 'all' },
        { id: 'toggleBase', label: 'Base', domain: 'normal' },
        { id: 'toggleDesecrated', label: 'Dese', domain: 'desecrated' },
        { id: 'toggleEssence', label: 'Ess', domain: 'essence' },
        { id: 'toggleCorrupted', label: 'Corr', domain: 'corrupted' }
    ];

    const POE1_PRIMARY_TOGGLES = [
        { id: 'toggleAll', label: 'All', domain: 'all' },
        { id: 'toggleNormal', label: 'Normal', domain: 'normal' },
        { id: 'toggleEldritch', label: 'Eldritch', domain: ['eldritch_eater', 'eldritch_searing'] },
        { id: 'toggleCrafting', label: 'Crafting', domain: 'master' }
    ];

    const POE1_OVERFLOW_TOGGLES = [
        { id: 'toggleShaper', label: 'Shaper', domain: 'shaper' },
        { id: 'toggleElder', label: 'Elder', domain: 'elder' },
        { id: 'toggleCrusader', label: 'Crusader', domain: 'crusader' },
        { id: 'toggleRedeemer', label: 'Redeemer', domain: 'redeemer' },
        { id: 'toggleHunter', label: 'Hunter', domain: 'hunter' },
        { id: 'toggleWarlord', label: 'Warlord', domain: 'warlord' },
        { id: 'toggleVeiled', label: 'Veiled', domain: 'veiled' },
        { id: 'toggleCorrupted', label: 'Corrupted', domain: 'corrupted' },
        { id: 'toggleSynthesis', label: 'Synthesis', domain: 'synthesis' },
        { id: 'toggleDelve', label: 'Delve', domain: 'delve' },
        { id: 'toggleIncursion', label: 'Incursion', domain: 'incursion' },
        { id: 'toggleEssence', label: 'Essence', domain: 'essence' },
        { id: 'toggleScourge', label: 'Scourge', domain: 'scourge' },
        { id: 'toggleBestiary', label: 'Bestiary', domain: 'bestiary' },
        { id: 'toggleSentinel', label: 'Sentinel', domain: 'sentinel' },
        { id: 'toggleInfamous', label: 'Infamous', domain: 'infamous' }
    ];

    let allDomainButtonIds = [];
    let overflowMenuOpen = false;

    function renderDomainToggles() {
        const container = document.getElementById('domainFilters');
        if (!container) return;

        // Clear existing buttons (keep the label)
        const label = container.querySelector('.cp-filters-label');
        container.innerHTML = '';
        if (label) container.appendChild(label);

        const isPoe1 = overlayVersionMode === 'poe1';
        const primaryToggles = isPoe1 ? POE1_PRIMARY_TOGGLES : POE2_TOGGLES;
        const overflowToggles = isPoe1 ? POE1_OVERFLOW_TOGGLES : [];

        allDomainButtonIds = [];

        // Render primary toggles
        primaryToggles.forEach((toggle, index) => {
            const btn = document.createElement('button');
            btn.id = toggle.id;
            btn.className = 'domain-toggle' + (index === 0 ? ' active' : '');
            // Store domain as JSON if it's an array
            btn.dataset.domain = Array.isArray(toggle.domain) ? JSON.stringify(toggle.domain) : toggle.domain;
            btn.textContent = toggle.label;
            container.appendChild(btn);
            allDomainButtonIds.push(toggle.id);
        });

        // Add overflow menu for PoE1
        if (isPoe1 && overflowToggles.length > 0) {
            const moreBtn = document.createElement('button');
            moreBtn.id = 'toggleMoreDomains';
            moreBtn.className = 'domain-toggle more-domains-btn';
            moreBtn.textContent = '+ More';
            moreBtn.style.position = 'relative';
            
            const overflowMenu = document.createElement('div');
            overflowMenu.id = 'domainOverflowMenu';
            overflowMenu.className = 'domain-overflow-menu';
            overflowMenu.style.cssText = 'display:none; position:absolute; top:100%; right:0; margin-top:4px; background:var(--bg-secondary); border:1px solid var(--border-color); border-radius:4px; box-shadow:0 4px 12px rgba(0,0,0,0.3); z-index:1000; min-width:120px; max-height:300px; overflow-y:auto;';

            overflowToggles.forEach(toggle => {
                const btn = document.createElement('button');
                btn.id = toggle.id;
                btn.className = 'domain-toggle overflow-item';
                btn.dataset.domain = Array.isArray(toggle.domain) ? JSON.stringify(toggle.domain) : toggle.domain;
                btn.textContent = toggle.label;
                btn.style.cssText = 'display:block; width:100%; text-align:left; padding:6px 12px; border:none; background:transparent; color:var(--text-primary); cursor:pointer; font-size:12px;';
                btn.addEventListener('mouseenter', () => btn.style.background = 'var(--bg-tertiary)');
                btn.addEventListener('mouseleave', () => btn.style.background = 'transparent');
                overflowMenu.appendChild(btn);
                allDomainButtonIds.push(toggle.id);
            });

            moreBtn.appendChild(overflowMenu);
            moreBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                overflowMenuOpen = !overflowMenuOpen;
                overflowMenu.style.display = overflowMenuOpen ? 'block' : 'none';
            });

            container.appendChild(moreBtn);

            // Close overflow menu when clicking outside
            document.addEventListener('click', () => {
                if (overflowMenuOpen) {
                    overflowMenuOpen = false;
                    overflowMenu.style.display = 'none';
                }
            });
        }

        // Attach click handlers to all toggles
        allDomainButtonIds.forEach(id => {
            const btn = document.getElementById(id);
            if (btn) {
                btn.addEventListener('click', () => {
                    // Remove active class from all domain buttons
                    allDomainButtonIds.forEach(otherId => {
                        const otherBtn = document.getElementById(otherId);
                        if (otherBtn) otherBtn.classList.remove('active');
                    });
                    // Add active class to clicked button
                    btn.classList.add('active');
                    // Close overflow menu if open
                    if (overflowMenuOpen) {
                        overflowMenuOpen = false;
                        const menu = document.getElementById('domainOverflowMenu');
                        if (menu) menu.style.display = 'none';
                    }
                    // Re-render with new filter
                    if (window.originalData) try { renderFilteredContent(window.originalData); } catch {}
                });
            }
        });
        
        // Safety check: ensure at least one toggle is active (default to "All")
        const hasActive = allDomainButtonIds.some(id => {
            const btn = document.getElementById(id);
            return btn && btn.classList.contains('active');
        });
        if (!hasActive) {
            const toggleAll = document.getElementById('toggleAll');
            if (toggleAll) toggleAll.classList.add('active');
        }
    }

    function markCharacterAction(actionKey) {
        if (!actionKey) return;
        updateLastContext({ view: 'character', action: `character:${actionKey}` });
    }

    function markItemsAction(actionKey) {
        if (!actionKey) return;
        updateLastContext({ view: 'items', action: `items:${actionKey}` });
    }

    function markToolsAction(actionKey) {
        if (!actionKey) return;
        updateLastContext({ view: 'tools', action: `tools:${actionKey}` });
    }

    function markHistoryAction() {
        updateLastContext({ view: 'history', action: 'history:merchant' });
    }

    // Track which high-level views are allowed by the current feature configuration
    const featureAvailability = {
        modifiers: true,
        crafting: true,
        character: true,
        history: true,
        tools: true
    };

    function setFeatureAvailability(flags) {
        if (!flags) return;
        if (typeof flags.modifiers === 'boolean') featureAvailability.modifiers = flags.modifiers;
        if (typeof flags.crafting === 'boolean') featureAvailability.crafting = flags.crafting;
        if (typeof flags.character === 'boolean') featureAvailability.character = flags.character;
        if (typeof flags.history === 'boolean') featureAvailability.history = flags.history;
        if (typeof flags.tools === 'boolean') featureAvailability.tools = flags.tools;
    }

    function isViewAvailable(view) {
        if (view === 'modifiers') return !!featureAvailability.modifiers;
        if (view === 'history') return !!featureAvailability.history;
        if (view === 'crafting') return !!featureAvailability.crafting;
        if (view === 'character') return !!featureAvailability.character;
        return true;
    }

    function pickFirstAvailableView(preferred) {
        const order = [];
        if (preferred) order.push(preferred);
        order.push('modifiers', 'character', 'crafting', 'history');
        const seen = new Set();
        for (const view of order) {
            if (seen.has(view)) continue;
            seen.add(view);
            if (view === 'modifiers' && featureAvailability.modifiers) return 'modifiers';
            if (view === 'character' && featureAvailability.character) return 'character';
            if (view === 'crafting' && featureAvailability.crafting) return 'crafting';
            if (view === 'history' && featureAvailability.history) return 'history';
        }
        return null;
    }

    // === Image Path Helper ===
    // Convert imageLocal field to file:// URL for bundled images (SYNC version for templates)
    function getImagePath(item) {
        // Use new imageLocal field (clean local paths, no poedb URLs!)
        if (item.imageLocal) {
            // In development: file:///C:/Users/.../packages/overlay/bundled-images/...
            // In production: file:///C:/Program Files/.../resources/bundled-images/...
            // The path will be resolved by main process, but we can construct it client-side too
            return item.imageLocal; // Will be handled by image auto-resolver
        }
        
        // Fallback to old image field (deprecated, will be removed)
        if (item.image && item.image.startsWith('http')) {
            return item.image; // Will trigger old resolver
        }
        
        return ''; // No image available
    }

    function setHeader(title, subtitle=''){
        if (headerTitleEl) headerTitleEl.textContent = title || '';
        if (headerSubtitleEl) headerSubtitleEl.textContent = subtitle || '';
    }

    // Footer tab helpers: keep only the current tab blue
    function setActiveTab(tabId){
        const targetTab = document.getElementById(tabId);
        if (!targetTab) return;
        if (window.getComputedStyle(targetTab).display === 'none') return;
        const tabs = [
            document.getElementById('tabModifier'),
            document.getElementById('tabHistory'),
            document.getElementById('craftingTab'),
            document.getElementById('characterTab'),
            document.getElementById('itemsTab'),
            document.getElementById('toolsTab')
        ].filter(Boolean);
        tabs.forEach(t => {
            if (!t) return;
            const active = (t.id === tabId);
            t.classList.toggle('active', active);
            t.style.background = active ? 'var(--accent-blue)' : 'var(--bg-tertiary)';
            t.style.color = active ? '#fff' : 'var(--text-primary)';
            t.style.borderColor = active ? 'var(--accent-blue)' : 'var(--border-color)';
        });
    }
    function closeAllMenus(){
        const cm = document.getElementById('craftingMenu'); if (cm) cm.style.display='none';
        const ch = document.getElementById('characterMenu'); if (ch) ch.style.display='none';
        const im = document.getElementById('itemsMenu'); if (im) im.style.display='none';
        const tm = document.getElementById('toolsMenu'); if (tm) tm.style.display='none';
    }

    // Helper: show/hide Modifiers control panel
    function setControlPanelVisible(visible){
        const cpEl = document.getElementById('controlPanel');
        if (cpEl) cpEl.style.display = visible ? '' : 'none';
    }

    // Helper: ensure history is hidden when switching away from history view
    function hideHistoryView(){
        const hist = document.getElementById('historyContainer');
        const histHeader = document.getElementById('historyHeaderMain');
        if (hist) hist.style.display = 'none';
        if (histHeader) histHeader.style.display = 'none';
    }

    // Clean view switching: only one container visible at a time
    function setView(view){
    const previousView = activeView;
    let targetView = view;
        if (view === 'modifiers' && !featureAvailability.modifiers) {
            targetView = pickFirstAvailableView('character');
        } else if (view === 'crafting' && !featureAvailability.crafting) {
            targetView = featureAvailability.character ? 'character' : pickFirstAvailableView('history');
        } else if (view === 'character' && !featureAvailability.character) {
            targetView = featureAvailability.crafting ? 'crafting' : pickFirstAvailableView('modifiers');
        } else if (view === 'history' && !featureAvailability.history) {
            targetView = pickFirstAvailableView('modifiers');
        }

        if (!targetView) {
            console.warn('[View] No available view to show (feature set disabled)');
            return;
        }

        if (targetView !== view) {
            console.log(`[View] Requested "${view}" but feature disabled, falling back to "${targetView}"`);
        }
        view = targetView;
        const content = document.getElementById('content');
        const crafting = document.getElementById('craftingPanel');
        const history = document.getElementById('historyContainer');
        const histHeaderMain = document.getElementById('historyHeaderMain');
        const histFiltersHeader = document.getElementById('historyHeader');
        
        if (crafting) {
            crafting.classList.remove('regex-mode');
            if (crafting.dataset.regexPrevOverflow) {
                crafting.style.overflow = crafting.dataset.regexPrevOverflow;
                delete crafting.dataset.regexPrevOverflow;
            } else {
                crafting.style.overflow = 'auto';
            }
        }

        // ALWAYS remove ALL view classes first
    document.body.classList.remove('crafting-mode', 'view-history', 'view-modifiers', 'view-character');
        
        // ALWAYS hide ALL containers first
        if (content) content.style.display = 'none';
        if (crafting) crafting.style.display = 'none';
        if (history) history.style.display = 'none';
        // DO NOT set inline styles on history headers - let CSS handle it via body classes
        
        // Show only the requested view
        if (view === 'modifiers'){
            if (content) content.style.display = '';
            setControlPanelVisible(true);
            document.body.classList.add('view-modifiers');
            // Show whittling badge on modifiers view (if data available, will be set by renderFilteredContent)
            const whittlingInfo = document.getElementById('whittlingInfo');
            if (whittlingInfo && whittlingInfo.innerHTML) {
                whittlingInfo.style.display = 'inline-flex';
            }
            try { window.OverlayHistory?.onLeaveView?.(); } catch {}
        } else if (view === 'crafting' || view === 'character'){
            if (crafting) { 
                crafting.style.display = 'block'; 
                if (previousView !== view) {
                    crafting.innerHTML = ''; 
                }
            }
            setControlPanelVisible(false);
            document.body.classList.add('crafting-mode');
            if (view === 'character') {
                document.body.classList.add('view-character');
            }
            // Hide whittling badge on crafting views
            const whittlingInfo = document.getElementById('whittlingInfo');
            if (whittlingInfo) whittlingInfo.style.display = 'none';
            try { window.OverlayHistory?.onLeaveView?.(); } catch {}
        } else if (view === 'history'){
            // Show the container with inline style, but let CSS handle headers
            if (history) history.style.display = 'flex';
            setControlPanelVisible(false);
            document.body.classList.add('view-history');
            // Hide whittling badge on history view
            const whittlingInfo = document.getElementById('whittlingInfo');
            if (whittlingInfo) whittlingInfo.style.display = 'none';
            
            // DEBUG: Check what's actually happening
            setTimeout(() => {
                const container = document.getElementById('historyContainer');
                const header = document.getElementById('historyHeader');
                const headerMain = document.getElementById('historyHeaderMain');
                console.log('=== HISTORY VIEW DEBUG ===');
                console.log('Body classes:', document.body.className);
                console.log('Container:', container ? {
                    display: window.getComputedStyle(container).display,
                    visibility: window.getComputedStyle(container).visibility,
                    inlineStyle: container.style.display
                } : 'NOT FOUND');
                console.log('Header (filter bar):', header ? {
                    display: window.getComputedStyle(header).display,
                    visibility: window.getComputedStyle(header).visibility,
                    inlineStyle: header.style.display,
                    offsetHeight: header.offsetHeight,
                    offsetWidth: header.offsetWidth
                } : 'NOT FOUND');
                console.log('HeaderMain:', headerMain ? {
                    display: window.getComputedStyle(headerMain).display,
                    inlineStyle: headerMain.style.display
                } : 'NOT FOUND');
            }, 100);
            
            try { window.OverlayHistory?.onEnterView?.(); } catch {}
        }
        
    activeView = view;
    updateLastContext({ view });
        console.log('setView:', view, 'body classes:', document.body.className);
    }

    function recordHeaderAction(title) {
        if (!title) return;
        const key = String(title).toLowerCase();
    if (key === 'liquid emotions') { markCraftingAction('liquid-emotions'); return; }
    if (key === 'annoints') { markCraftingAction('annoints'); return; }
    if (key === 'essences') { markCraftingAction('essences'); return; }
    if (key === 'omens') { markCraftingAction('omens'); return; }
    if (key === 'currency') { markCraftingAction('currency'); return; }
    if (key === 'catalysts') { markCraftingAction('catalysts'); return; }
    if (key === 'socketables') { markCraftingAction('socketables'); return; }
    if (key === 'poe1 runegrafts' || key === 'runegrafts') { markCraftingAction('poe1-runegrafts'); return; }
    if (key === 'poe1 horticrafting' || key === 'horticrafting') { markCraftingAction('poe1-horticrafting'); return; }
    if (key === 'poe1 bestiary' || key === 'bestiary') { markCraftingAction('poe1-bestiary'); return; }
    if (key === 'poe1 scarabs') { markCraftingAction('poe1-scarabs'); return; }
    if (key === 'poe1 currency') { markCraftingAction('poe1-currency'); return; }
    if (key === 'poe1 essences') { markCraftingAction('poe1-essences'); return; }
    if (key === 'poe1 fossils') { markCraftingAction('poe1-fossils'); return; }
    if (key === 'poe1 embers' || key === 'poe1 allflames') { markCraftingAction('poe1-embers'); return; }
    if (key === 'gems') { markCharacterAction('gems'); return; }
    if (key === 'quest passives') { markCharacterAction('quest-passives'); return; }
    if (key === 'keystones') { markCharacterAction('keystones'); return; }
    if (key === 'ascendancy passives') { markCharacterAction('asc-passives'); return; }
    if (key === 'atlas nodes') { markCharacterAction('atlas-nodes'); return; }
    if (key === 'ascendancy notables') { markCharacterAction('poe1-asc-notables'); return; }
    if (key === 'divination cards') { markCharacterAction('poe1-divination-cards'); return; }
    if (key === 'poe1 anointments' || key === 'anointments') { markCharacterAction('poe1-anointments'); return; }
    if (key === 'tattoos') { markCharacterAction('poe1-tattoos'); return; }
    if (key === 'glossar') { markCharacterAction('glossar'); return; }
    if (key === 'uniques') { markItemsAction('uniques'); return; }
    if (key === 'bases') { markItemsAction('bases'); return; }
    if (key === 'merchant history') { markHistoryAction(); return; }
    if (key === 'regex builder') { markToolsAction('regex'); return; }
    if (key === 'map regex') { markToolsAction('poe1-regex'); return; }
    if (key === 'vorici calculator') { markToolsAction('poe1-vorici'); return; }
    }

    async function runStoredAction(action) {
        if (!action) return false;
        try {
            if (action.startsWith('modifiers:')) {
                if (!featureAvailability.modifiers) return false;
                const category = action.slice('modifiers:'.length);
                if (!category) return false;
                await populateCategoryDropdown();
                const select = document.getElementById('categorySelect');
                if (!select) return false;
                const option = Array.from(select.options || []).find(opt => opt.value === category);
                if (!option) return false;
                select.value = category;
                lastSwitchedCategory = '';
                lastSwitchTime = 0;
                switchCategory();
                return true;
            }

            if (action.startsWith('crafting:')) {
                if (!featureAvailability.crafting) return false;
                const key = action.slice('crafting:'.length);
                const menuItem = document.querySelector(`#craftingMenu .crafting-menu-item[data-action="${key}"]`);
                if (menuItem && window.getComputedStyle(menuItem).display === 'none') return false;
                setActiveTab('craftingTab');
                closeAllMenus();
                setView('crafting');
                if (key === 'liquid-emotions') { await showLiquidEmotions(); setHeader('Liquid Emotions'); recordHeaderAction('Liquid Emotions'); return true; }
                if (key === 'annoints') { await showAnnoints(); setHeader('Annoints'); recordHeaderAction('Annoints'); return true; }
                if (key === 'essences') { await showEssences(); setHeader('Essences'); recordHeaderAction('Essences'); return true; }
                if (key === 'omens') { await showOmens(); setHeader('Omens'); recordHeaderAction('Omens'); return true; }
                if (key === 'currency') { await showCurrency(); setHeader('Currency'); recordHeaderAction('Currency'); return true; }
                if (key === 'catalysts') { await showCatalysts(); setHeader('Catalysts'); recordHeaderAction('Catalysts'); return true; }
                if (key === 'socketables') { await showSocketables(); setHeader('Socketables'); recordHeaderAction('Socketables'); return true; }
                // PoE1 Crafting actions
                if (key === 'poe1-runegrafts') { await showPoe1Runegrafts(); setHeader('PoE1 Runegrafts'); recordHeaderAction('PoE1 Runegrafts'); return true; }
                if (key === 'poe1-horticrafting') { await showPoe1Horticrafting(); setHeader('PoE1 Horticrafting'); recordHeaderAction('PoE1 Horticrafting'); return true; }
                if (key === 'poe1-bestiary') { await showPoe1Bestiary(); setHeader('PoE1 Bestiary'); recordHeaderAction('PoE1 Bestiary'); return true; }
                if (key === 'poe1-scarabs') { await showPoe1Scarabs(); setHeader('PoE1 Scarabs'); recordHeaderAction('PoE1 Scarabs'); return true; }
                if (key === 'poe1-currency') { await showPoe1Currency(); setHeader('PoE1 Currency'); recordHeaderAction('PoE1 Currency'); return true; }
                if (key === 'poe1-essences') { await showPoe1Essences(); setHeader('PoE1 Essences'); recordHeaderAction('PoE1 Essences'); return true; }
                if (key === 'poe1-fossils') { await showPoe1Fossils(); setHeader('PoE1 Fossils'); recordHeaderAction('PoE1 Fossils'); return true; }
                if (key === 'poe1-embers') { await showPoe1Embers(); setHeader('PoE1 Allflames'); recordHeaderAction('PoE1 Allflames'); return true; }
                return false;
            }

            if (action.startsWith('character:')) {
                if (!featureAvailability.character) return false;
                const key = action.slice('character:'.length);
                const menuItem = document.querySelector(`#characterMenu .character-menu-item[data-action="${key}"]`);
                if (menuItem && window.getComputedStyle(menuItem).display === 'none') return false;
                if (key === 'gems') {
                    setActiveTab('characterTab');
                    setView('character');
                    await showGems();
                    setHeader('Gems');
                    recordHeaderAction('Gems');
                    return true;
                }
                if (key === 'keystones') {
                    setActiveTab('characterTab');
                    setView('character');
                    await showKeystones();
                    setHeader('Keystones');
                    recordHeaderAction('Keystones');
                    return true;
                }
                if (key === 'asc-passives') {
                    setActiveTab('characterTab');
                    setView('character');
                    await showAscendancyPassives();
                    setHeader('Ascendancy Passives');
                    recordHeaderAction('Ascendancy Passives');
                    return true;
                }
                if (key === 'atlas-nodes') {
                    setActiveTab('characterTab');
                    setView('character');
                    await showAtlasNodes();
                    setHeader('Atlas Nodes');
                    recordHeaderAction('Atlas Nodes');
                    return true;
                }
                if (key === 'quest-passives') {
                    setActiveTab('characterTab');
                    setView('character');
                    if (window.OverlayQuestPassives?.show) { try { await window.OverlayQuestPassives.show(); } catch {} }
                    setHeader('Quest Passives');
                    recordHeaderAction('Quest Passives');
                    return true;
                }
                if (key === 'glossar') {
                    setActiveTab('characterTab');
                    setView('character');
                    try { await showGlossar(); } catch {}
                    setHeader('Glossar');
                    recordHeaderAction('Glossar');
                    return true;
                }
                if (key === 'poe1-divination-cards') {
                    setActiveTab('characterTab');
                    setView('character');
                    if (window.OverlayPoe1DivinationCards?.show) { try { await window.OverlayPoe1DivinationCards.show(); } catch {} }
                    setHeader('Divination Cards');
                    recordHeaderAction('Divination Cards');
                    return true;
                }
                if (key === 'poe1-asc-notables') {
                    setActiveTab('characterTab');
                    setView('character');
                    if (window.OverlayPoe1AscendancyNotables?.show) { try { await window.OverlayPoe1AscendancyNotables.show(); } catch {} }
                    setHeader('Ascendancy Notables');
                    recordHeaderAction('Ascendancy Notables');
                    return true;
                }
                if (key === 'poe1-anointments') {
                    setActiveTab('characterTab');
                    setView('character');
                    if (window.OverlayPoe1Anointments?.show) { try { await window.OverlayPoe1Anointments.show(); } catch {} }
                    setHeader('PoE1 Anointments');
                    recordHeaderAction('PoE1 Anointments');
                    return true;
                }
                if (key === 'poe1-tattoos') {
                    setActiveTab('characterTab');
                    setView('character');
                    if (window.OverlayPoe1Tattoos?.show) { try { await window.OverlayPoe1Tattoos.show(); } catch {} }
                    setHeader('Tattoos');
                    recordHeaderAction('Tattoos');
                    return true;
                }
                if (key === 'poe1-gems-list') {
                    setActiveTab('characterTab');
                    setView('character');
                    if (window.OverlayPoe1Gems?.showList) { try { await window.OverlayPoe1Gems.showList(); } catch {} }
                    setHeader('Gems');
                    recordHeaderAction('Gems');
                    return true;
                }
                return false;
            }

            if (action.startsWith('items:')) {
                if (!featureAvailability.crafting) return false;
                const key = action.slice('items:'.length);
                const menuItem = document.querySelector(`#itemsMenu .items-menu-item[data-action="${key}"]`);
                if (menuItem && window.getComputedStyle(menuItem).display === 'none') return false;
                setActiveTab('itemsTab');
                setView('crafting');
                if (key === 'uniques') { await showUniques(); setHeader('Uniques'); recordHeaderAction('Uniques'); return true; }
                if (key === 'bases') { await showBases(); setHeader('Bases'); recordHeaderAction('Bases'); return true; }
                return false;
            }

            if (action === 'history:merchant') {
                if (!featureAvailability.history) return false;
                setActiveTab('tabHistory');
                setView('history');
                setHeader('Merchant History');
                recordHeaderAction('Merchant History');
                try { window.OverlayHistory?.onEnterView?.(); } catch {}
                return true;
            }

            if (action === 'tools:regex') {
                const menuItem = document.querySelector('#toolsMenu .tools-menu-item[data-action="regex"]');
                if (menuItem && window.getComputedStyle(menuItem).display === 'none') return false;
                setActiveTab('toolsTab');
                closeAllMenus();
                setView('crafting');
                if (window.OverlayRegex?.show) { try { await window.OverlayRegex.show(); } catch {} }
                setHeader('Regex Builder');
                recordHeaderAction('Regex Builder');
                return true;
            }

            if (action === 'tools:poe1-regex') {
                const menuItem = document.querySelector('#toolsMenu .tools-menu-item[data-action="poe1-regex"]');
                if (menuItem && window.getComputedStyle(menuItem).display === 'none') return false;
                setActiveTab('toolsTab');
                closeAllMenus();
                setView('crafting');
                if (window.OverlayRegexPoe1?.show) { try { window.OverlayRegexPoe1.show(); } catch {} }
                setHeader('Map Regex');
                recordHeaderAction('Map Regex');
                return true;
            }

            if (action === 'tools:poe1-vorici') {
                const menuItem = document.querySelector('#toolsMenu .tools-menu-item[data-action="poe1-vorici"]');
                if (menuItem && window.getComputedStyle(menuItem).display === 'none') return false;
                setActiveTab('toolsTab');
                closeAllMenus();
                setView('crafting');
                if (window.OverlayPoe1Vorici?.show) { try { await window.OverlayPoe1Vorici.show(); } catch {} }
                // Apply pending Vorici data if available
                if (window.pendingVoriciData && window.OverlayPoe1Vorici?.applyItem) {
                    try {
                        window.OverlayPoe1Vorici.applyItem(window.pendingVoriciData);
                        console.log('Applied pending Vorici data');
                    } catch (err) {
                        console.warn('Failed to apply pending Vorici data', err);
                    }
                }
                setHeader('Vorici Calculator');
                recordHeaderAction('Vorici Calculator');
                return true;
            }
        } catch (err) {
            console.warn('[runStoredAction] Failed to restore action', action, err);
        }
        return false;
    }

    async function openFirstAvailableAction() {
                                        recordHeaderAction('Gems'); // Record action for Gems
            await populateCategoryDropdown();
            if (!firstSelectableCategory) {
                const select = document.getElementById('categorySelect');
                if (select) {
                    const option = Array.from(select.options || []).find(opt => !opt.disabled && opt.value);
                    firstSelectableCategory = option ? option.value : null;
                                    recordHeaderAction('Merchant History'); // Record action for Merchant History
            }
            if (firstSelectableCategory) {
                return await runStoredAction(`modifiers:${firstSelectableCategory}`);
            }
        }

        if (featureAvailability.crafting) {
            const craftingActions = ['liquid-emotions', 'annoints', 'essences', 'omens', 'currency', 'catalysts', 'socketables', 'poe1-runegrafts', 'poe1-horticrafting', 'poe1-bestiary', 'poe1-scarabs', 'poe1-currency', 'poe1-essences', 'poe1-fossils', 'poe1-embers'];
            for (const key of craftingActions) {
                if (await runStoredAction(`crafting:${key}`)) return true;
            }
            const characterActions = ['gems', 'keystones', 'asc-passives', 'atlas-nodes', 'quest-passives', 'glossar', 'poe1-divination-cards', 'poe1-asc-notables', 'poe1-anointments', 'poe1-tattoos', 'poe1-gems-list'];
            for (const key of characterActions) {
                if (await runStoredAction(`character:${key}`)) return true;
            }
            const itemActions = ['uniques', 'bases'];
            for (const key of itemActions) {
                if (await runStoredAction(`items:${key}`)) return true;
            }
            if (await runStoredAction('tools:regex')) return true;
            if (await runStoredAction('tools:poe1-regex')) return true;
        }

        if (featureAvailability.history) {
            if (await runStoredAction('history:merchant')) return true;
        }

        // Fallback: show modifiers view even if no category (empty state)
        if (featureAvailability.modifiers) {
            setView('modifiers');
            setHeader('Modifier');
            return true;
        }

        return false;
    }

    async function openLastOrDefault() {
        if (await runStoredAction(lastContext?.action)) return;
        await openFirstAvailableAction();
    }

    // debug logger removed

    // Global variables
    let currentData = null;
    let allSections = [];
    // ===== Delegations only; implementations live in TS modules via window.Overlay* facades =====
    // Catalysts, Socketables, Omens
    async function showCatalysts(){ if (window.OverlayCatalysts && window.OverlayCatalysts.show) { try { return await window.OverlayCatalysts.show(); } catch {} } }
    function renderCatalysts(list){ if (window.OverlayCatalysts && window.OverlayCatalysts.render) { try { return window.OverlayCatalysts.render(list); } catch {} } }
    async function showSocketables(){ if (window.OverlaySocketables && window.OverlaySocketables.show) { try { return await window.OverlaySocketables.show(); } catch {} } }
    function renderSocketables(list){ if (window.OverlaySocketables && window.OverlaySocketables.render) { try { return window.OverlaySocketables.render(list); } catch {} } }
    async function showOmens(){ if (window.OverlayOmens && window.OverlayOmens.show) { try { return await window.OverlayOmens.show(); } catch {} } }
    function renderOmens(list){ if (window.OverlayOmens && window.OverlayOmens.render) { try { return window.OverlayOmens.render(list); } catch {} } }
    async function showCurrency(){ if (window.OverlayCurrency && window.OverlayCurrency.show) { try { return await window.OverlayCurrency.show(); } catch {} } }
    function renderCurrency(list){ if (window.OverlayCurrency && window.OverlayCurrency.render) { try { return window.OverlayCurrency.render(list); } catch {} } }
    // Uniques, Bases, Glossar (version-aware)
    async function showUniques(){ 
        const isPoe1 = overlayVersionMode === 'poe1';
        if (isPoe1) {
            if (window.OverlayPoe1Uniques && window.OverlayPoe1Uniques.show) { 
                try { return await window.OverlayPoe1Uniques.show(); } catch {} 
            }
        } else {
            if (window.OverlayUniques && window.OverlayUniques.show) { 
                try { return await window.OverlayUniques.show(); } catch {} 
            }
        }
    }
    function renderUniques(groups){ if (window.OverlayUniques && window.OverlayUniques.render) { try { return window.OverlayUniques.render(groups); } catch {} } }
    async function showBases(){ 
        const isPoe1 = overlayVersionMode === 'poe1';
        if (isPoe1) {
            if (window.OverlayPoe1Bases && window.OverlayPoe1Bases.show) { 
                try { return await window.OverlayPoe1Bases.show(); } catch {} 
            }
        } else {
            if (window.OverlayBases && window.OverlayBases.show) { 
                try { return await window.OverlayBases.show(); } catch {} 
            }
        }
    }
    function renderBases(groups){ if (window.OverlayBases && window.OverlayBases.render) { try { return window.OverlayBases.render(groups); } catch {} } }
    async function showGlossar(){ if (window.OverlayGlossar && window.OverlayGlossar.show) { try { return await window.OverlayGlossar.show(); } catch {} } }
    function renderGlossar(list){ if (window.OverlayGlossar && window.OverlayGlossar.render) { try { return window.OverlayGlossar.render(list); } catch {} } }
    // Annoints, Essences
    async function showAnnoints(){ if (window.OverlayAnnoints && window.OverlayAnnoints.show) { try { return await window.OverlayAnnoints.show(); } catch {} } }
    async function showEssences(){ if (window.OverlayEssences && window.OverlayEssences.show) { try { return await window.OverlayEssences.show(); } catch {} } }
    function renderEssences(list){ if (window.OverlayEssences && window.OverlayEssences.render) { try { return window.OverlayEssences.render(list); } catch {} } }
    // PoE1 Crafting
    async function showPoe1Runegrafts(){ if (window.OverlayPoe1Runegrafts && window.OverlayPoe1Runegrafts.show) { try { return await window.OverlayPoe1Runegrafts.show(); } catch {} } }
    async function showPoe1Horticrafting(){ if (window.OverlayPoe1Horticrafting && window.OverlayPoe1Horticrafting.show) { try { return await window.OverlayPoe1Horticrafting.show(); } catch {} } }
    async function showPoe1Bestiary(){ if (window.OverlayPoe1Bestiary && window.OverlayPoe1Bestiary.show) { try { return await window.OverlayPoe1Bestiary.show(); } catch {} } }
    async function showPoe1Scarabs(){ if (window.OverlayPoe1Scarabs && window.OverlayPoe1Scarabs.show) { try { return await window.OverlayPoe1Scarabs.show(); } catch {} } }
    function renderPoe1Scarabs(list){ if (window.OverlayPoe1Scarabs && window.OverlayPoe1Scarabs.render) { try { return window.OverlayPoe1Scarabs.render(list); } catch {} } }
    async function showPoe1Currency(){ if (window.OverlayPoe1Currency && window.OverlayPoe1Currency.show) { try { return await window.OverlayPoe1Currency.show(); } catch {} } }
    function renderPoe1Currency(list){ if (window.OverlayPoe1Currency && window.OverlayPoe1Currency.render) { try { return window.OverlayPoe1Currency.render(list); } catch {} } }
    async function showPoe1Essences(){ if (window.OverlayPoe1Essences && window.OverlayPoe1Essences.show) { try { return await window.OverlayPoe1Essences.show(); } catch {} } }
    function renderPoe1Essences(list){ if (window.OverlayPoe1Essences && window.OverlayPoe1Essences.render) { try { return window.OverlayPoe1Essences.render(list); } catch {} } }
    async function showPoe1Fossils(){ if (window.OverlayPoe1Fossils && window.OverlayPoe1Fossils.show) { try { return await window.OverlayPoe1Fossils.show(); } catch {} } }
    function renderPoe1Fossils(list){ if (window.OverlayPoe1Fossils && window.OverlayPoe1Fossils.render) { try { return window.OverlayPoe1Fossils.render(list); } catch {} } }
    async function showPoe1Embers(){ if (window.OverlayPoe1Embers && window.OverlayPoe1Embers.show) { try { return await window.OverlayPoe1Embers.show(); } catch {} } }
    function renderPoe1Embers(list){ if (window.OverlayPoe1Embers && window.OverlayPoe1Embers.render) { try { return window.OverlayPoe1Embers.render(list); } catch {} } }
    // History aliases and thin wrappers
    let historyState = null;
    // Grab history state as soon as possible; refresh on DOMContentLoaded too
    try { historyState = window.OverlayHistory?.historyState || null; } catch {}
    window.addEventListener('DOMContentLoaded', () => { try { historyState = window.OverlayHistory?.historyState || historyState; } catch {} });
    async function updateSessionUI(){ return await window.OverlayHistory?.updateSessionUI?.(); }
    function keyForRow(r){ return window.OverlayHistory?.keyForRow?.(r); }
    function addToTotals(p){ return window.OverlayHistory?.addToTotalsWrapper?.(p); }
    function renderHistoryTotals(){ return window.OverlayHistory?.renderHistoryTotalsWrapper?.(); }
    function renderHistoryActiveFilters(){ return window.OverlayHistory?.renderHistoryActiveFiltersWrapper?.(); }
    function renderHistoryList(){ return window.OverlayHistory?.renderHistoryListWrapper?.(); }
    function renderHistoryDetail(i){ return window.OverlayHistory?.renderHistoryDetailWrapper?.(i); }
    function applySort(list){ return window.OverlayHistory?.applySort?.(list, window.OverlayHistory?.historyState?.sort) ?? list; }
    function applyFilters(list){ return window.OverlayHistory?.applyFilters?.(list, window.OverlayHistory?.historyState?.filters) ?? list; }
    async function refreshHistory(){ return await window.OverlayHistory?.onManualRefresh?.(); }
    function recomputeChartSeriesFromStore(){ return window.OverlayHistory?.recomputeChartSeriesFromStore?.(); }
    function updateHistoryChartFromTotals(t){ return window.OverlayHistory?.updateHistoryChartFromTotals?.(t); }
    function drawHistoryChart(){ return window.OverlayHistory?.drawHistoryChart?.(); }
    function setChartCurrency(cur){ return window.OverlayHistory?.setChartCurrency?.(cur); }
    function nextAllowedRefreshAt(){ return window.OverlayHistory?.nextAllowedRefreshAt?.(); }
    function updateHistoryRefreshButton(){ return window.OverlayHistory?.updateHistoryRefreshButton?.(); }
    // HTML wrapper previously called refreshHistoryIfAllowed without required render callbacks (causing TypeError in minified bundle).
    async function refreshHistoryIfAllowed(origin){ 
        try {
            const H = window.OverlayHistory;
            if (!H || typeof H.refreshHistoryIfAllowed !== 'function') return;
            return await H.refreshHistoryIfAllowed(
                origin,
                (detailCb)=>{ try { H.renderHistoryList(detailCb); } catch(e){ console.warn('[History HTML wrapper] list render failed', e);} },
                (idx)=>{ try { H.renderHistoryDetail(idx); } catch(e){ console.warn('[History HTML wrapper] detail render failed', e);} }
            );
        } catch(e){ console.warn('[History HTML wrapper] refreshHistoryIfAllowed error', e); }
    }
    function parseRateLimitHeaders(headers, status){ return window.OverlayHistory?.parseRateLimitHeaders?.(headers, status) ?? 0; }

        // Function to render content with current filters applied
        function renderFilteredContent(data) { try { return window.OverlayModifiers?.renderFilteredContent?.(data); } catch {} }

        // Minimal helpers for panel visibility and category detail
        function hideAllPanels(){
            const cp = document.getElementById('craftingPanel'); 
            if (cp) cp.style.display='none'; 
            document.body.classList.remove('crafting-mode');
            hideHistoryView(); // Always hide history when switching views
            // Explicitly hide merchant history header elements to prevent leakage
            const mhIds = ['historyHeader','historyHeaderLeft','historyHeaderMain','historyPinned','historyActiveFilters'];
            mhIds.forEach(function(id){ var el=document.getElementById(id); if(el) el.style.display='none'; });
        }
        function prepareCharacterPanel(title){
            const cp = document.getElementById('craftingPanel'); if (!cp) return;
            // Hide other views to avoid overlap
            const mod = document.getElementById('content'); if (mod) mod.style.display='none';
            hideHistoryView(); // Ensure history is hidden
            document.body.classList.add('crafting-mode');
            cp.style.display='block';
            setControlPanelVisible(false);
            // Update shared reference used by character subviews
            craftingPanelEl = cp;
            cp.innerHTML='';
            
        }
        function renderCategoryDetail(data){
            try { window.OverlayModifiers?.mechanicsPostProcess?.(data); } catch {}
            window.originalData = data; currentData = data;
            try { renderFilteredContent(data); } catch {}
        }
        

    const CATEGORY_ICON_FALLBACK = 'body';
    const CATEGORY_ICON_MAP = {
        ALL: 'aggregated',
        DESECRATED: 'aggregated',
        ESSENCE: 'aggregated',
        CORRUPTED: 'aggregated',
        SOCKETABLE: 'aggregated',
        SOCKETABLES: 'aggregated',
        RELICS: 'relic',
        BODY_ARMOURS: 'body',
        HELMETS: 'helmet',
        GLOVES: 'gloves',
        BOOTS: 'boots',
        RINGS: 'ring',
        AMULETS: 'amulet',
        BELTS: 'belt',
        BUCKLERS: 'shield',
        SHIELDS: 'shield',
        BOWS: 'bow',
        CROSSBOWS: 'crossbow',
        CLAWS: 'blade',
        DAGGERS: 'blade',
        ONE_HAND_SWORDS: 'blade',
        TWO_HAND_SWORDS: 'blade',
        ONE_HAND_AXES: 'axe',
        TWO_HAND_AXES: 'axe',
        ONE_HAND_MACES: 'mace',
        TWO_HAND_MACES: 'mace',
        FLAILS: 'flail',
        SPEARS: 'spear',
        QUARTERSTAVES: 'spear',
        STAVES: 'spear',
        FOCI: 'foci',
        WANDS: 'wand',
        SCEPTRES: 'wand',
        QUIVERS: 'quiver',
        CHARMS: 'charm',
        LIFE_FLASKS: 'flask-life',
        MANA_FLASKS: 'flask-mana',
        TRAPS: 'trap',
        WAYSTONES: 'waystone',
        STRONGBOX: 'relic',
        STRONGBOX_UNIQUES: 'relic',
        EXPEDITION_LOGBOOK: 'tablet',
        PRECURSOR_TABLET: 'tablet',
        EXPEDITION_PRECURSOR_TABLET: 'tablet',
        BREACH_PRECURSOR_TABLET: 'tablet',
        RITUAL_PRECURSOR_TABLET: 'tablet',
        OVERSEER_PRECURSOR_TABLET: 'tablet',
        DELIRIUM_PRECURSOR_TABLET: 'tablet',
        TAPESTRY_RELIC: 'relic',
        AMPHORA_RELIC: 'relic',
        COFFER_RELIC: 'relic',
        INCENSE_RELIC: 'relic',
        SEAL_RELIC: 'relic',
        URN_RELIC: 'relic',
        VASE_RELIC: 'relic',
        EMERALD: 'jewel',
        RUBY: 'jewel',
        SAPPHIRE: 'jewel',
        TIME_LOST_EMERALD: 'jewel',
        TIME_LOST_RUBY: 'jewel',
        TIME_LOST_SAPPHIRE: 'jewel',
        JEWELS: 'jewel'
    };

    const ATTRIBUTE_STYLES = {
        none: { gradient: 'linear-gradient(120deg, rgba(255,255,255,0.04) 0%, rgba(14,21,30,0.18) 100%)', textColor: 'var(--text-primary)' },
        str: { gradient: 'linear-gradient(120deg, rgba(203,72,72,0.28) 0%, rgba(203,72,72,0.08) 100%)', textColor: 'var(--text-primary)' },
        dex: { gradient: 'linear-gradient(120deg, rgba(76,158,108,0.28) 0%, rgba(76,158,108,0.08) 100%)', textColor: 'var(--text-primary)' },
        int: { gradient: 'linear-gradient(120deg, rgba(87,118,214,0.28) 0%, rgba(87,118,214,0.08) 100%)', textColor: 'var(--text-primary)' },
        str_dex: { gradient: 'linear-gradient(120deg, rgba(203,72,72,0.26) 0%, rgba(76,158,108,0.22) 75%, rgba(76,158,108,0.08) 100%)', textColor: 'var(--text-primary)' },
        str_int: { gradient: 'linear-gradient(120deg, rgba(203,72,72,0.26) 0%, rgba(87,118,214,0.22) 75%, rgba(87,118,214,0.08) 100%)', textColor: 'var(--text-primary)' },
        dex_int: { gradient: 'linear-gradient(120deg, rgba(76,158,108,0.26) 0%, rgba(87,118,214,0.22) 75%, rgba(87,118,214,0.08) 100%)', textColor: 'var(--text-primary)' },
        // Jewels
        ruby: { gradient: 'linear-gradient(120deg, rgba(220,38,38,0.28) 0%, rgba(220,38,38,0.08) 100%)', textColor: 'var(--text-primary)' },
        emerald: { gradient: 'linear-gradient(120deg, rgba(34,197,94,0.28) 0%, rgba(34,197,94,0.08) 100%)', textColor: 'var(--text-primary)' },
        sapphire: { gradient: 'linear-gradient(120deg, rgba(59,130,246,0.28) 0%, rgba(59,130,246,0.08) 100%)', textColor: 'var(--text-primary)' },
        // Flasks & Charms
        life_flask: { gradient: 'linear-gradient(120deg, rgba(220,38,38,0.28) 0%, rgba(220,38,38,0.08) 100%)', textColor: 'var(--text-primary)' },
        mana_flask: { gradient: 'linear-gradient(120deg, rgba(59,130,246,0.28) 0%, rgba(59,130,246,0.08) 100%)', textColor: 'var(--text-primary)' },
        charms: { gradient: 'linear-gradient(120deg, rgba(168,85,247,0.28) 0%, rgba(168,85,247,0.08) 100%)', textColor: 'var(--text-primary)' },
        // Waystones
        waystone_low: { gradient: 'linear-gradient(120deg, rgba(120,120,120,0.28) 0%, rgba(120,120,120,0.08) 100%)', textColor: 'var(--text-primary)' },
        waystone_mid: { gradient: 'linear-gradient(120deg, rgba(234,179,8,0.28) 0%, rgba(234,179,8,0.08) 100%)', textColor: 'var(--text-primary)' },
        waystone_high: { gradient: 'linear-gradient(120deg, rgba(220,38,38,0.28) 0%, rgba(220,38,38,0.08) 100%)', textColor: 'var(--text-primary)' },
        // Aggregated
        corrupted: { gradient: 'linear-gradient(120deg, rgba(220,38,38,0.28) 0%, rgba(220,38,38,0.08) 100%)', textColor: 'var(--text-primary)' },
        essence: { gradient: 'linear-gradient(120deg, rgba(59,130,246,0.28) 0%, rgba(59,130,246,0.08) 100%)', textColor: 'var(--text-primary)' },
        socketables: { gradient: 'linear-gradient(120deg, rgba(34,197,94,0.28) 0%, rgba(34,197,94,0.08) 100%)', textColor: 'var(--text-primary)' },
        desecrated: { gradient: 'linear-gradient(120deg, rgba(21,128,61,0.28) 0%, rgba(21,128,61,0.08) 100%)', textColor: 'var(--text-primary)' }
    };

    const CATEGORY_ATTRIBUTE_OVERRIDES = {
        BOWS: 'dex',
        CROSSBOWS: 'dex',
        QUIVERS: 'dex',
        CLAWS: 'dex_int',
        DAGGERS: 'dex_int',
        ONE_HAND_SWORDS: 'str_dex',
        TWO_HAND_SWORDS: 'str_dex',
        ONE_HAND_AXES: 'str',
        TWO_HAND_AXES: 'str',
        ONE_HAND_MACES: 'str',
        TWO_HAND_MACES: 'str',
        FLAILS: 'str',
        SPEARS: 'str_dex',
        QUARTERSTAVES: 'str_int',
        STAVES: 'int',
        WANDS: 'int',
        SCEPTRES: 'str_int',
        FOCI: 'int',
        BUCKLERS: 'dex',
        SHIELDS: 'str',
        TRAPS: 'dex',
        BELTS: 'str'
    };

    const iconUrlCache = new Map();
    const categoryMetaCache = new Map();
    const missingCategoryIconNames = new Set();

    function normalizeCategoryKey(value) {
        return String(value || '')
            .replace(/\s+/g, '_')
            .replace(/-+/g, '_')
            .replace(/__+/g, '_')
            .trim()
            .toUpperCase();
    }

    function splitCategoryKey(key) {
        const parts = key.split('_');
        const attrParts = [];
        while (parts.length) {
            const tail = parts[parts.length - 1];
            if (tail === 'STR' || tail === 'DEX' || tail === 'INT') {
                attrParts.unshift(tail.toLowerCase());
                parts.pop();
            } else {
                break;
            }
        }
        const baseKey = parts.join('_');
        const attributeKey = attrParts.length ? attrParts.join('_') : '';
        return { baseKey, attributeKey };
    }

    function inferAttribute(baseKey, attributeKey) {
        if (attributeKey) return attributeKey;
        if (CATEGORY_ATTRIBUTE_OVERRIDES[baseKey]) return CATEGORY_ATTRIBUTE_OVERRIDES[baseKey];
        return '';
    }

    function inferIconName(baseKey, normalizedKey) {
        const direct = CATEGORY_ICON_MAP[normalizedKey] || CATEGORY_ICON_MAP[baseKey];
        if (direct) return direct;
        if (/RELIC$/.test(baseKey)) return 'relic';
        if (baseKey.includes('RELIC')) return 'relic';
        if (baseKey.includes('WAYSTONE')) return 'waystone';
        if (baseKey.includes('TABLET') || baseKey.endsWith('LOGBOOK')) return 'tablet';
        if (/EMERALD|RUBY|SAPPHIRE|JEWEL|TIME_LOST/.test(baseKey)) return 'jewel';
        return CATEGORY_ICON_FALLBACK;
    }

    async function resolveIconUrl(iconName) {
        if (!iconName) return '';
        if (iconUrlCache.has(iconName)) {
            const cached = iconUrlCache.get(iconName);
            if (cached) return cached;
        }
        let resolved = '';
        try {
            if (window.electronAPI?.getBundledImagePath) {
                resolved = await window.electronAPI.getBundledImagePath(`svgicons/${iconName}.svg`);
            }
        } catch {}
        if (!resolved && window.bundledImages?.toFileUrl) {
            try { resolved = window.bundledImages.toFileUrl(`svgicons/${iconName}.svg`); } catch {}
        }
        resolved = normalizeIconUrl(resolved);
        if (!resolved) {
            resolved = '';
        }
        iconUrlCache.set(iconName, resolved);
        return resolved;
    }

    function composeBackgroundLayers(gradient) {
        return gradient || '';
    }

    function toDevServerFsUrl(pathFragment) {
        if (!pathFragment) return '';
        try {
            const origin = window.location?.origin;
            if (!origin || !/^https?:/i.test(window.location.protocol)) return '';
            const normalized = pathFragment.replace(/\\/g, '/');
            const trimmed = normalized.startsWith('/') && /^[A-Za-z]:/.test(normalized.slice(1))
                ? normalized.slice(1)
                : normalized;
            const encoded = encodeURI(trimmed);
            return `${origin}/@fs/${encoded}`;
        } catch (err) {
            console.debug('[CategoryDropdown] toDevServerFsUrl failed', err);
            return '';
        }
    }

    function normalizeIconUrl(value) {
        if (!value) return '';
        const str = String(value).trim();
        if (!str) return '';
        if (/^data:/i.test(str) || /^https?:/i.test(str)) return str;
        if (/^file:/i.test(str)) {
            const withoutScheme = str.replace(/^file:\/+/, '');
            const devUrl = toDevServerFsUrl(withoutScheme);
            if (devUrl) return devUrl;
            return `file:///${withoutScheme.replace(/\\/g, '/')}`;
        }
        const normalized = str.replace(/\\/g, '/');
        if (/^[A-Za-z]:/.test(normalized) || /^\/[A-Za-z]:/.test(normalized)) {
            const devUrl = toDevServerFsUrl(normalized);
            if (devUrl) return devUrl;
            const cleaned = normalized.replace(/^\//, '');
            return `file:///${cleaned}`;
        }
        if (normalized.startsWith('//')) return `file:${normalized}`;
        if (normalized.startsWith('/')) return `file://${normalized}`;
        return `file:///${normalized}`;
    }

    function applyElementMeta(element, meta) {
        if (!element) return;
        element.dataset.category = meta.category || '';
        element.dataset.attr = meta.attributeKey || '';
        element.dataset.gradient = meta.gradient || '';
        element.dataset.iconUrl = meta.iconUrl || '';
        element.dataset.iconName = meta.iconResolved || meta.iconRequested || '';
        element.dataset.textColor = meta.textColor || 'var(--text-primary)';
        element.dataset.iconRequested = meta.iconRequested || '';
        if (meta.displayLabel) {
            element.dataset.displayLabel = meta.displayLabel;
        }
        if (meta.iconMissing) {
            element.dataset.iconMissing = meta.iconMissing;
        } else if (element.dataset.iconMissing) {
            element.removeAttribute('data-icon-missing');
        }
    }

    function applyOptionDecor(option, meta) {
        option.classList.add('category-option');
        applyElementMeta(option, meta);
        option.dataset.displayLabel = meta.displayLabel || option.textContent || option.value || '';
        const background = composeBackgroundLayers(meta.gradient);
        if (background) {
            option.style.backgroundImage = background;
            option.style.backgroundRepeat = 'no-repeat';
            option.style.backgroundSize = '100% 100%';
            option.style.backgroundPosition = 'center';
        } else {
            option.style.backgroundImage = 'none';
        }
        option.style.paddingLeft = meta.iconUrl ? '34px' : '12px';
        option.style.color = meta.textColor || 'var(--text-primary)';
    }

    function getCategoryDropdownElements() {
        return {
            wrapper: document.getElementById('categorySelectWrapper'),
            button: document.getElementById('categorySelectDisplay'),
            menu: document.getElementById('categorySelectMenu'),
            select: document.getElementById('categorySelect'),
            label: document.getElementById('categorySelectLabel'),
            icon: document.getElementById('categorySelectIcon')
        };
    }

    function updateCategoryMenuSelection(value) {
        const { menu } = getCategoryDropdownElements();
        if (!menu) return;
        const items = menu.querySelectorAll('.category-menu-item');
        items.forEach((item) => {
            item.classList.toggle('active', item.dataset.value === value);
        });
    }

    function toggleCategoryMenu(forceOpen) {
        const { wrapper, button, menu } = getCategoryDropdownElements();
        if (!wrapper || !button || !menu) return;
        const shouldOpen = typeof forceOpen === 'boolean' ? forceOpen : !wrapper.classList.contains('open');
        wrapper.classList.toggle('open', shouldOpen);
        button.setAttribute('aria-expanded', shouldOpen ? 'true' : 'false');
        menu.setAttribute('aria-hidden', shouldOpen ? 'false' : 'true');
        if (shouldOpen) {
            setTimeout(() => {
                const searchInput = menu.querySelector('.category-menu-search input');
                if (searchInput) {
                    try {
                        searchInput.focus();
                        searchInput.setSelectionRange(searchInput.value.length, searchInput.value.length);
                    } catch {}
                }
            }, 0);
        }
    }

    function closeCategoryMenu() {
        toggleCategoryMenu(false);
    }

    function renderCategoryMenu(items, selectedValue, options = {}) {
        const { menu } = getCategoryDropdownElements();
        if (!menu) return;
        menu.innerHTML = '';

        let searchInputRef = null;
        if (options.showSearch) {
            const searchWrap = document.createElement('div');
            searchWrap.className = 'category-menu-search';
            const searchInput = document.createElement('input');
            searchInput.type = 'search';
            searchInput.placeholder = 'Filter categories...';
            searchInput.autocomplete = 'off';
            searchInput.spellcheck = false;
            searchInput.value = options.filterValue || '';
            searchInput.setAttribute('aria-label', 'Filter modifier categories');
            searchInput.addEventListener('input', (event) => {
                const val = (event.target && typeof event.target.value === 'string') ? event.target.value : '';
                if (typeof options.onFilterChange === 'function') {
                    options.onFilterChange(val);
                }
            });
            searchInput.addEventListener('keydown', (event) => {
                if (event.key === 'ArrowDown') {
                    event.preventDefault();
                    const firstItem = menu.querySelector('.category-menu-item');
                    if (firstItem) firstItem.focus();
                } else if (event.key === 'Escape') {
                    if (searchInput.value) {
                        event.preventDefault();
                        event.stopPropagation();
                        searchInput.value = '';
                        if (typeof options.onFilterChange === 'function') {
                            options.onFilterChange('');
                        }
                    }
                }
            });
            searchWrap.appendChild(searchInput);
            menu.appendChild(searchWrap);
            searchInputRef = searchInput;
        }

        const frag = document.createDocumentFragment();
        items.forEach((item, index) => {
            if (item.type === 'group-label') {
                const labelEl = document.createElement('div');
                labelEl.className = 'category-menu-group-label';
                labelEl.textContent = item.label;
                frag.appendChild(labelEl);
                return;
            }
            if (item.type === 'divider') {
                if (index === items.length - 1) return;
                const divider = document.createElement('div');
                divider.className = 'category-menu-divider';
                frag.appendChild(divider);
                return;
            }
            if (item.type === 'option') {
                const btn = document.createElement('button');
                btn.type = 'button';
                btn.className = 'category-menu-item';
                btn.setAttribute('role', 'option');
                applyElementMeta(btn, item.meta);
                btn.dataset.value = item.meta.category;
                btn.style.backgroundImage = item.meta.gradient || 'none';
                if (item.meta.gradient) {
                    btn.classList.add('has-background');
                }
                btn.style.backgroundRepeat = 'no-repeat';
                btn.style.backgroundSize = '100% 100%';
                btn.style.backgroundPosition = 'center';
                btn.style.color = item.meta.textColor || 'var(--text-primary)';
                const iconSpan = document.createElement('span');
                iconSpan.className = 'category-menu-item-icon';
                iconSpan.textContent = '';
                if (item.meta.iconUrl) {
                    const iconImg = document.createElement('img');
                    iconImg.src = item.meta.iconUrl;
                    iconImg.alt = '';
                    iconImg.loading = 'lazy';
                    iconSpan.appendChild(iconImg);
                    iconSpan.classList.add('has-icon');
                } else {
                    iconSpan.classList.remove('has-icon');
                }
                const labelSpan = document.createElement('span');
                labelSpan.className = 'category-menu-item-label';
                labelSpan.textContent = item.meta.displayLabel || item.displayLabel || item.meta.category.replace(/_/g, ' ');
                btn.appendChild(iconSpan);
                btn.appendChild(labelSpan);
                if (item.meta.category === selectedValue) {
                    btn.classList.add('active');
                }
                btn.addEventListener('click', () => {
                    const { select } = getCategoryDropdownElements();
                    if (!select) return;
                    if (select.value !== item.meta.category) {
                        select.value = item.meta.category;
                        select.dispatchEvent(new Event('change', { bubbles: true }));
                    } else {
                        syncCategorySelectAppearance();
                    }
                    closeCategoryMenu();
                });
                btn.addEventListener('keydown', (event) => {
                    if (event.key === 'ArrowUp') {
                        const siblings = Array.from(menu.querySelectorAll('.category-menu-item'));
                        const currentIdx = siblings.indexOf(btn);
                        if (currentIdx > 0) {
                            siblings[currentIdx - 1].focus();
                            event.preventDefault();
                        } else if (searchInputRef) {
                            searchInputRef.focus();
                            event.preventDefault();
                        }
                    } else if (event.key === 'ArrowDown') {
                        const siblings = Array.from(menu.querySelectorAll('.category-menu-item'));
                        const currentIdx = siblings.indexOf(btn);
                        if (currentIdx >= 0 && currentIdx < siblings.length - 1) {
                            siblings[currentIdx + 1].focus();
                            event.preventDefault();
                        }
                    }
                });
                frag.appendChild(btn);
            }
        });
        menu.appendChild(frag);
        updateCategoryMenuSelection(selectedValue || '');

        if (options.autoFocusSearch && searchInputRef) {
            setTimeout(() => {
                try {
                    searchInputRef.focus();
                    searchInputRef.setSelectionRange(searchInputRef.value.length, searchInputRef.value.length);
                } catch {}
            }, 0);
        }
    }

    function syncCategorySelectAppearance() {
        const select = document.getElementById('categorySelect');
        const { button, label, icon } = getCategoryDropdownElements();
        if (!select || !button || !label || !icon) return;
        const option = select.options[select.selectedIndex] || null;
        if (!option || !option.value) {
            button.style.backgroundImage = ATTRIBUTE_STYLES.none.gradient;
            button.classList.add('has-background');
            button.style.color = 'var(--text-primary)';
            label.textContent = 'Select category...';
            icon.style.backgroundImage = 'none';
            icon.classList.remove('has-icon');
            updateCategoryMenuSelection('');
            return;
        }
        const gradient = option.dataset.gradient || ATTRIBUTE_STYLES.none.gradient;
        const iconUrl = option.dataset.iconUrl || '';
        const textColor = option.dataset.textColor || 'var(--text-primary)';
        const displayLabel = option.dataset.displayLabel || option.textContent || option.value;
        if (gradient) {
            button.style.backgroundImage = gradient;
            button.classList.add('has-background');
        } else {
            button.style.backgroundImage = 'none';
            button.classList.remove('has-background');
        }
        button.style.color = textColor;
        label.textContent = displayLabel;
        icon.replaceChildren();
        if (iconUrl) {
            const displayImg = document.createElement('img');
            displayImg.src = iconUrl;
            displayImg.alt = '';
            icon.appendChild(displayImg);
            icon.classList.add('has-icon');
        } else {
            icon.classList.remove('has-icon');
        }
        updateCategoryMenuSelection(option.value);
    }

    async function buildCategoryMeta(category) {
        const normalizedKey = normalizeCategoryKey(category);
        if (categoryMetaCache.has(normalizedKey)) return categoryMetaCache.get(normalizedKey);
        const { baseKey, attributeKey } = splitCategoryKey(normalizedKey);
        let inferredAttr = inferAttribute(baseKey, attributeKey);
        
        // Override attribute style for special categories
        if (baseKey === 'RUBY' || baseKey === 'TIME_LOST_RUBY') inferredAttr = 'ruby';
        else if (baseKey === 'EMERALD' || baseKey === 'TIME_LOST_EMERALD') inferredAttr = 'emerald';
        else if (baseKey === 'SAPPHIRE' || baseKey === 'TIME_LOST_SAPPHIRE') inferredAttr = 'sapphire';
        else if (baseKey === 'LIFE_FLASKS') inferredAttr = 'life_flask';
        else if (baseKey === 'MANA_FLASKS') inferredAttr = 'mana_flask';
        else if (baseKey === 'CHARMS') inferredAttr = 'charms';
        else if (baseKey === 'CORRUPTED') inferredAttr = 'corrupted';
        else if (baseKey === 'ESSENCE') inferredAttr = 'essence';
        else if (baseKey === 'SOCKETABLES' || baseKey === 'SOCKETABLE') inferredAttr = 'socketables';
        else if (baseKey === 'DESECRATED') inferredAttr = 'desecrated';
        else if (baseKey.startsWith('WAYSTONES_')) {
            // Extract tier from waystone category
            const tierMatch = baseKey.match(/WAYSTONES_(\d+)/);
            if (tierMatch) {
                const tier = parseInt(tierMatch[1], 10);
                if (tier >= 1 && tier <= 5) inferredAttr = 'waystone_low';
                else if (tier >= 6 && tier <= 10) inferredAttr = 'waystone_mid';
                else if (tier >= 11) inferredAttr = 'waystone_high';
            }
        }
        
        const rawIconName = inferIconName(baseKey, normalizedKey);
        let iconRequested = rawIconName;
        let iconUrl = await resolveIconUrl(rawIconName);
        let iconResolved = rawIconName;
        let iconMissing = '';
        if (iconUrl) {
            if (missingCategoryIconNames.delete(rawIconName)) {
                window.__missingCategoryIcons = Array.from(missingCategoryIconNames);
            }
        } else if (rawIconName !== CATEGORY_ICON_FALLBACK) {
            iconMissing = rawIconName;
            if (!missingCategoryIconNames.has(rawIconName)) {
                console.info('[CategoryDropdown] Missing icon asset detected:', `${rawIconName}.svg`, 'â€” using fallback.');
                missingCategoryIconNames.add(rawIconName);
                window.__missingCategoryIcons = Array.from(missingCategoryIconNames);
            }
            iconRequested = CATEGORY_ICON_FALLBACK;
            iconUrl = await resolveIconUrl(iconRequested);
            iconResolved = iconRequested;
        }
        const attrStyle = ATTRIBUTE_STYLES[inferredAttr] || ATTRIBUTE_STYLES.none;
        const meta = {
            category,
            normalizedKey,
            baseKey,
            attributeKey: inferredAttr || 'none',
            iconRequested,
            iconResolved,
            iconUrl,
            textColor: attrStyle.textColor,
            gradient: attrStyle.gradient,
            iconMissing
        };
        categoryMetaCache.set(normalizedKey, meta);
        return meta;
    }

    function formatCategoryLabel(category) {
        if (!category) return '';
        let label = String(category);
        try {
            label = decodeURIComponent(label);
        } catch {}
        label = label.replace(/_/g, ' ').trim();
        label = label.replace(/\bPoe1\b/gi, 'PoE1');
        label = label.replace(/\bPoe2\b/gi, 'PoE2');
        label = label.replace(/\bMavens\b/i, "Maven's");
        return label;
    }

    // Populate category dropdown on load
        async function populateCategoryDropdown() {
            if (!window.electronAPI || !window.electronAPI.getAllCategories) return;
            try {
                const rawCategories = await window.electronAPI.getAllCategories();
                const categorySelect = document.getElementById('categorySelect');
                if (!categorySelect) return;
                const categories = (rawCategories || []).filter((entry) => String(entry || '').toUpperCase() !== 'ALL');
        
        // Version-specific aggregated categories
        const POE2_AGGREGATED = ['DESECRATED','ESSENCE','CORRUPTED','SOCKETABLE','SOCKETABLES'];
        const POE1_AGGREGATED = ['INFLUENCE','ELDRITCH','MASTER_CRAFTING','CORRUPTED','SYNTHESISED','VEILED'];
        const POE1_INFLUENCES = ['SHAPER','ELDER','CRUSADER','REDEEMER','HUNTER','WARLORD'];
        const POE1_ELDRITCH = ['ELDRITCH_EATER','ELDRITCH_SEARING'];
        const POE1_DOMAINS = ['DELVE','INCURSION','ESSENCE','SCOURGE','BESTIARY','SENTINEL','INFAMOUS'];
        
        const AGGREGATED_CATEGORIES = overlayVersionMode === 'poe1' ? POE1_AGGREGATED : POE2_AGGREGATED;
        const aggregatedSet = new Set(AGGREGATED_CATEGORIES.map(c => c.toUpperCase()));

                function classify(cat) {
                    const u = cat.toUpperCase();
                    
                    // PoE1-specific classification
                    if (overlayVersionMode === 'poe1') {
                        if (aggregatedSet.has(u)) return 'aggregated';
                        if (POE1_INFLUENCES.includes(u)) return 'influences';
                        if (POE1_ELDRITCH.includes(u)) return 'eldritch';
                        if (POE1_DOMAINS.includes(u)) return 'domains';
                        
                        // Special gear (unique items that don't fit normal categories)
                        if (u === 'WARSTAVES') return 'special_gear';
                        if (u.match(/^(CONVOKING_WAND|FISHING_ROD|RUNE_DAGGER|STEEL_BRACER|THRUSTING_ONE_HAND|UNSET_RING|WARSTAFF)/)) {
                            return 'special_gear';
                        }
                        
                        // Special bases (Bone, Runic)
                        if (u.match(/^(BONE_|RUNIC_)/)) return 'special_gear'; // Combine with special gear
                        
                        // Idols
                        if (u.match(/_IDOL$/)) return 'idols';
                        
                        // Jewels
                        if (u.match(/JEWEL|ABYSS/)) return 'jewels';
                        
                        // Charms
                        if (u.match(/CHARM/)) return 'charms';
                        
                        // Flasks and Tinctures/Trinkets
                        if (u.match(/FLASK|TINCTURE|TRINKET/)) return 'flasks';
                        
                        // Blueprints and Contracts
                        if (u.match(/BLUEPRINT|CONTRACT/)) return 'extra';
                        
                        // Gear categories (including Warstaves but excluding individual GEAR)
                        if (u.match(/^(BODY_ARMOUR|BOOT|GLOVE|HELMET|SHIELD|BELT|AMULET|RING|QUIVER|ONE_HAND|TWO_HAND|BOW|CLAW|DAGGER|SCEPTRE|WAND|STAVE|AXE|MACE|SWORD)/) && u !== 'GEAR') {
                            return 'gear';
                        }
                        
                        // Default to other
                        return 'other';
                    }
                    
                    // PoE2 classification
                    if (aggregatedSet.has(u)) return 'aggregated';
                    if (u.startsWith('WAYSTONES_')) return 'waystones';
                    if (/(_RELIC)$/.test(u)) return 'relics';
                    if (u === 'RELICS') return 'relics';
                    if (u === 'LIFE_FLASKS' || u === 'MANA_FLASKS' || u === 'CHARMS') return 'flasks';
                    if (u === 'PRECURSOR_TABLET' || /_PRECURSOR_TABLET$/.test(u)) return 'tablets';
                    if (u === 'JEWELS' || /^RUBY$/.test(u) || /^EMERALD$/.test(u) || /^SAPPHIRE$/.test(u) || /^TIME-LOST_RUBY$/.test(u) || /^TIME-LOST_EMERALD$/.test(u) || /^TIME-LOST_SAPPHIRE$/.test(u)) return 'jewels';
                    if (u === 'STRONGBOX' || u === 'STRONGBOX_UNIQUES' || u === 'EXPEDITION_LOGBOOK') return 'mechanics';
                    return 'gear';
                }

                // Version-specific buckets
                const poe2Buckets = { aggregated:[], gear:[], waystones:[], relics:[], flasks:[], tablets:[], jewels:[], mechanics:[] };
                const poe1Buckets = { aggregated:[], influences:[], eldritch:[], domains:[], gear:[], special_gear:[], jewels:[], flasks:[], extra:[], idols:[], charms:[], other:[] };
                const buckets = overlayVersionMode === 'poe1' ? poe1Buckets : poe2Buckets;
                
                const nonModifierCats = new Set([
                    'LIQUID_EMOTIONS','ANNOINTS','ESSENCES','OMENS','CATALYSTS','SOCKETABLES','SOCKETABLE','GEMS','KEYSTONES','ASCENDANCY_PASSIVES','ATLAS_NODES','KEYWORDS','UNIQUES','BASES','CURRENCY','GEAR','UNIQUE_MAPS','UNIQUE MAPS'
                ]);
                // First, put all aggregated explicitly into the aggregated bucket (preserve our preferred order)
                const aggregatedAdded = new Set();
                for (const a of AGGREGATED_CATEGORIES) {
                    const hit = (categories||[]).find(c => String(c).toUpperCase() === a);
                    if (hit) {
                        const key = String(hit).toUpperCase();
                        if (aggregatedAdded.has(key)) continue;
                        aggregatedAdded.add(key);
                        buckets.aggregated.push(hit);
                    }
                }
                // Then, distribute the rest (excluding non-modifier and aggregated)
                for (const c of categories) {
                    const u = (c||'').toUpperCase();
                    if (aggregatedSet.has(u)) continue;
                    if (nonModifierCats.has(u)) continue;
                    const g = classify(c);
                    buckets[g].push(c);
                }

                const metaCacheForRun = new Map();

                async function ensureMeta(cat) {
                    if (!metaCacheForRun.has(cat)) {
                        const meta = await buildCategoryMeta(cat);
                        metaCacheForRun.set(cat, meta);
                    }
                    return metaCacheForRun.get(cat);
                }

                async function buildOptions(filterText='') {
                    const normalizedFilter = (filterText || '').toLowerCase();
                    const matchesFilter = (label) => !normalizedFilter || label.toLowerCase().includes(normalizedFilter);

                    const safeFilterText = escapeHtml(filterText || '');
                    categorySelect.innerHTML = `<option value="">${normalizedFilter ? `Filtering: "${safeFilterText}"` : 'Select category...'}</option>`;
                    const placeholder = categorySelect.options[0];
                    if (placeholder) {
                        placeholder.classList.add('category-placeholder');
                        placeholder.dataset.gradient = ATTRIBUTE_STYLES.none.gradient;
                        placeholder.dataset.iconUrl = '';
                        placeholder.dataset.textColor = ATTRIBUTE_STYLES.none.textColor;
                    }

                    const menuItems = [];

                    async function addGroup(label, list, transform) {
                        const subset = (list || []).filter((c) => {
                            const display = transform ? transform(c) : formatCategoryLabel(c);
                            return matchesFilter(display);
                        });
                        if (!subset.length) return;
                        const groupLabel = document.createElement('option');
                        groupLabel.textContent = label;
                        groupLabel.disabled = true;
                        groupLabel.classList.add('category-group-label');
                        categorySelect.appendChild(groupLabel);
                        menuItems.push({ type: 'group-label', label });

                        const ordered = subset.slice().sort();
                        for (const c of ordered) {
                            const opt = document.createElement('option');
                            const display = transform ? transform(c) : formatCategoryLabel(c);
                            opt.value = c;
                            opt.textContent = display;
                            const meta = await ensureMeta(c);
                            meta.displayLabel = display;
                            applyOptionDecor(opt, meta);
                            categorySelect.appendChild(opt);
                            menuItems.push({ type: 'option', meta });
                        }

                        const div = document.createElement('option');
                        div.textContent = 'â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€';
                        div.disabled = true;
                        div.classList.add('category-divider');
                        categorySelect.appendChild(div);
                        menuItems.push({ type: 'divider' });
                    }

                    if (overlayVersionMode === 'poe1') {
                        await addGroup('â€” Gear â€”', buckets.gear, (c) => formatCategoryLabel(c));
                        await addGroup('â€” Special Gear â€”', buckets.special_gear, (c) => formatCategoryLabel(c));
                        await addGroup('â€” Jewels â€”', buckets.jewels, (c) => formatCategoryLabel(c));
                        await addGroup('â€” Flasks â€”', buckets.flasks, (c) => formatCategoryLabel(c));
                        await addGroup('â€” Extra â€”', buckets.extra, (c) => formatCategoryLabel(c));
                        await addGroup('â€” Influences â€”', buckets.influences, (c) => formatCategoryLabel(c));
                        await addGroup('â€” Eldritch â€”', buckets.eldritch, (c) => {
                            const upper = c.toUpperCase();
                            if (upper.includes('EATER')) return 'Eater of Worlds';
                            if (upper.includes('SEARING')) return 'Searing Exarch';
                            return formatCategoryLabel(c.replace(/ELDRITCH_/i, ''));
                        });
                        await addGroup('â€” Domains â€”', buckets.domains, (c) => formatCategoryLabel(c));
                        await addGroup('â€” Aggregated â€”', buckets.aggregated, (c) => formatCategoryLabel(c).toUpperCase());
                        await addGroup('â€” Idols â€”', buckets.idols, (c) => formatCategoryLabel(c));
                        await addGroup('â€” Charms â€”', buckets.charms, (c) => formatCategoryLabel(c));
                        await addGroup('â€” Other â€”', buckets.other, (c) => formatCategoryLabel(c));
                    } else {
                        await addGroup('â€” Aggregated â€”', buckets.aggregated, (c) => formatCategoryLabel(c).toUpperCase());
                        await addGroup('â€” Gear â€”', buckets.gear, (c) => formatCategoryLabel(c));
                        await addGroup('â€” Waystones â€”', buckets.waystones, (c) => formatCategoryLabel(c));
                        await addGroup('â€” Relics â€”', buckets.relics, (c) => {
                            const name = formatCategoryLabel(c);
                            const u = c.toUpperCase();
                            if (u.includes('SEAL')) return `${name} [2x1]`;
                            if (u.includes('URN')) return `${name} [1x2]`;
                            if (u.includes('TAPESTRY')) return `${name} [3x1]`;
                            if (u.includes('AMPHORA')) return `${name} [1x3]`;
                            if (u.includes('INCENSE')) return `${name} [4x1]`;
                            if (u.includes('VASE')) return `${name} [1x4]`;
                            if (u.includes('COFFER')) return `${name} [2x2]`;
                            return name;
                        });
                        await addGroup('â€” Flasks & Charms â€”', buckets.flasks, (c) => formatCategoryLabel(c));
                        await addGroup('â€” Jewels â€”', buckets.jewels, (c) => formatCategoryLabel(c));
                        await addGroup('â€” Tablets â€”', buckets.tablets, (c) => formatCategoryLabel(c));
                        await addGroup('â€” Mechanics â€”', buckets.mechanics, (c) => formatCategoryLabel(c));
                    }

                    if (menuItems.length && menuItems[menuItems.length - 1]?.type === 'divider') {
                        menuItems.pop();
                    }

                    return menuItems;
                }

                let rebuildMenu;
                let filterDebounceId = 0;

                const handleFilterChange = (value) => {
                    const next = typeof value === 'string' ? value : '';
                    window.clearTimeout(filterDebounceId);
                    filterDebounceId = window.setTimeout(() => {
                        if (typeof rebuildMenu === 'function') {
                            rebuildMenu(next);
                        }
                    }, 90);
                };

                rebuildMenu = async (filterText) => {
                    categoryDropdownFilter = filterText || '';
                    const selectedBefore = categorySelect.value;
                    const menuItems = await buildOptions(categoryDropdownFilter);
                    const realOptions = Array.from(categorySelect.options || []).filter(opt => !opt.disabled && opt.value);

                    if (!firstSelectableCategory && realOptions.length) {
                        firstSelectableCategory = realOptions[0].value;
                    }

                    if (selectedBefore && realOptions.some(opt => opt.value === selectedBefore)) {
                        categorySelect.value = selectedBefore;
                    } else if (!realOptions.some(opt => opt.value === categorySelect.value)) {
                        categorySelect.selectedIndex = 0;
                    }

                    const { wrapper } = getCategoryDropdownElements();
                    const shouldFocusSearch = !!(wrapper && wrapper.classList.contains('open'));

                    renderCategoryMenu(menuItems || [], categorySelect.value || '', {
                        showSearch: true,
                        filterValue: categoryDropdownFilter,
                        autoFocusSearch: shouldFocusSearch,
                        onFilterChange: handleFilterChange
                    });

                    syncCategorySelectAppearance();
                    window.__missingCategoryIcons = Array.from(missingCategoryIconNames);
                };

                await rebuildMenu(categoryDropdownFilter);
                closeCategoryMenu();
            } catch (err) {
                console.warn('[populateCategoryDropdown] failed', err);
            }
        }
        // Wire initial controls on DOM ready
        document.addEventListener('DOMContentLoaded', async () => {
            try {
                const storedMode = await window.electronAPI?.getSetting?.('overlayVersion');
                if (storedMode === 'poe1' || storedMode === 'poe2') {
                    overlayVersionMode = storedMode;
                }
            } catch {}

            // Feature-aware tab visibility (hide disabled features)
            overlayHasAnyFeatures = true;
            try {
                const enabledFeatures = await window.electronAPI?.getEnabledFeatures?.();
                console.log('[FeatureFilter] Enabled features:', enabledFeatures);
                
                if (enabledFeatures) {
                    let modifiersEnabled = !!enabledFeatures.modifiers;
                    let historyEnabled = !!enabledFeatures.merchant;
                    let craftingViewEnabled = false;
                    let characterViewEnabled = false;

                    // Hide Modifier tab if disabled (version-aware: check poe1Modifiers for PoE1, modifiers for PoE2)
                    const modifiersConfig = overlayVersionMode === 'poe1' ? enabledFeatures.poe1Modifiers : enabledFeatures.modifiers;
                    
                    if (!modifiersConfig) {
                        console.log('[FeatureFilter] Hiding Modifier tab (modifiers disabled)');
                        const modTab = document.getElementById('tabModifier');
                        if (modTab) {
                            modTab.remove();
                            console.log('[FeatureFilter] Modifier tab removed');
                        }
                        modifiersEnabled = false;
                    } else {
                        modifiersEnabled = true;
                    }
                    
                    // Hide Merchant History tab if disabled
                    if (!enabledFeatures.merchant) {
                        console.log('[FeatureFilter] Hiding Merchant History tab (merchant disabled)');
                        const histTab = document.getElementById('tabHistory');
                        if (histTab) histTab.remove();
                        historyEnabled = false;
                    } else {
                        historyEnabled = true;
                    }
                    
                    // Filter Crafting submenu items (PoE2 and PoE1)
                    const craftingConfig = overlayVersionMode === 'poe1' ? enabledFeatures.poe1Crafting : enabledFeatures.crafting;
                    
                    console.log('[FeatureFilter] Crafting config:', { mode: overlayVersionMode, config: craftingConfig });
                    
                    if (!craftingConfig || !craftingConfig.enabled) {
                        console.log('[FeatureFilter] Hiding Crafting tab (crafting disabled or missing)');
                        const craftingTab = document.getElementById('craftingTab');
                        if (craftingTab) craftingTab.remove();
                    } else if (craftingConfig.enabled) {
                        const craftMenu = document.getElementById('craftingMenu');
                        const subs = craftingConfig.subcategories || {};
                        let anySubEnabled = false;
                        
                        console.log('[FeatureFilter] Crafting enabled, checking subcategories:', subs);
                        
                        if (craftMenu) {
                            const items = craftMenu.querySelectorAll('.crafting-menu-item');
                            items.forEach(item => {
                                const action = item.getAttribute('data-action');
                                let shouldShow = false;
                                
                                // PoE2 crafting items
                                if (action === 'liquid-emotions' && subs.liquidEmotions) shouldShow = true;
                                if (action === 'annoints' && subs.annoints) shouldShow = true;
                                if (action === 'essences' && subs.essences) shouldShow = true;
                                if (action === 'omens' && subs.omens) shouldShow = true;
                                if (action === 'currency' && subs.currency) shouldShow = true;
                                if (action === 'catalysts' && subs.catalysts) shouldShow = true;
                                if (action === 'socketables' && subs.socketables) shouldShow = true;
                                
                                // PoE1 crafting items
                                if (action === 'poe1-scarabs' && subs.scarabs) shouldShow = true;
                                if (action === 'poe1-runegrafts' && subs.runegrafts) shouldShow = true;
                                if (action === 'poe1-horticrafting' && subs.horticrafting) shouldShow = true;
                                if (action === 'poe1-bestiary' && subs.bestiary) shouldShow = true;
                                if (action === 'poe1-currency' && subs.currency) shouldShow = true;
                                if (action === 'poe1-essences' && subs.essences) shouldShow = true;
                                if (action === 'poe1-fossils' && subs.fossils) shouldShow = true;
                                if (action === 'poe1-embers' && subs.embers) shouldShow = true;
                                
                                if (shouldShow) {
                                    anySubEnabled = true;
                                    item.style.display = '';
                                    console.log('[FeatureFilter] Showing crafting item:', action);
                                } else {
                                    item.style.display = 'none';
                                }
                            });
                        }
                        
                        console.log('[FeatureFilter] Any crafting sub enabled:', anySubEnabled);
                        
                        // Hide entire Crafting tab if no subcategories enabled
                        if (!anySubEnabled) {
                            console.log('[FeatureFilter] No crafting subs enabled, removing tab');
                            const craftingTab = document.getElementById('craftingTab');
                            if (craftingTab) craftingTab.remove();
                        } else {
                            console.log('[FeatureFilter] Crafting tab should be visible');
                        }
                    }
                    if (document.getElementById('craftingTab')) craftingViewEnabled = true;
                    
                    // Filter Character submenu items (PoE2 and PoE1)
                    const isPoe1Mode = overlayVersionMode === 'poe1';
                    const poe2CharacterConfig = enabledFeatures.character;
                    const poe1CharacterConfig = enabledFeatures.poe1Character;

                    console.log('[FeatureFilter] Character configs:', {
                        mode: overlayVersionMode,
                        poe2: poe2CharacterConfig,
                        poe1: poe1CharacterConfig
                    });

                    const poe2CharacterEnabled = !!(poe2CharacterConfig && poe2CharacterConfig.enabled);
                    const poe1CharacterEnabled = !!(poe1CharacterConfig && poe1CharacterConfig.enabled);
                    const poe2Subs = poe2CharacterConfig?.subcategories || {};
                    const poe1Subs = poe1CharacterConfig?.subcategories || {};
                    const poe2GemsEnabled = poe2CharacterEnabled && !!poe2Subs.gems;
                    const poe1GemsEnabled = poe1CharacterEnabled && isPoe1Mode && !!poe1Subs.gems;

                    if (!poe2CharacterEnabled && !poe1CharacterEnabled) {
                        console.log('[FeatureFilter] Hiding Character tab (no character features enabled)');
                        const charTab = document.getElementById('characterTab');
                        if (charTab) charTab.remove();
                    } else {
                        const charMenu = document.getElementById('characterMenu');
                        let anySubEnabled = false;

                        console.log('[FeatureFilter] Character subcategories:', { poe2: poe2Subs, poe1: poe1Subs });

                        if (charMenu) {
                            const items = charMenu.querySelectorAll('.character-menu-item');
                            items.forEach(item => {
                                const action = item.getAttribute('data-action');
                                let shouldShow = false;

                                if (poe2CharacterEnabled) {
                                    if (action === 'quest-passives' && poe2Subs.questPassives) shouldShow = true;
                                    if (action === 'keystones' && poe2Subs.keystones) shouldShow = true;
                                    if (action === 'asc-passives' && poe2Subs.ascendancyPassives) shouldShow = true;
                                    if (action === 'atlas-nodes' && poe2Subs.atlasNodes) shouldShow = true;
                                    if (action === 'gems' && poe2Subs.gems) shouldShow = true;
                                    if (action === 'glossar' && poe2Subs.glossar) shouldShow = true;
                                }

                                if (poe1CharacterEnabled && isPoe1Mode) {
                                    if (action === 'poe1-divination-cards' && poe1Subs.divinationCards) shouldShow = true;
                                    if (action === 'poe1-asc-notables' && poe1Subs.ascendancyNotables) shouldShow = true;
                                    if (action === 'poe1-anointments' && poe1Subs.anointments) shouldShow = true;
                                    if (action === 'poe1-tattoos' && poe1Subs.tattoos) shouldShow = true;
                                    if (action === 'poe1-gems-list' && poe1Subs.gems) shouldShow = true;
                                }

                                if (shouldShow) {
                                    anySubEnabled = true;
                                    item.style.display = '';
                                    console.log('[FeatureFilter] Showing character item:', action);
                                } else {
                                    item.style.display = 'none';
                                }
                            });
                        }

                        console.log('[FeatureFilter] Any character sub enabled:', anySubEnabled);

                        if (!anySubEnabled) {
                            console.log('[FeatureFilter] No character subs enabled, removing tab');
                            const charTab = document.getElementById('characterTab');
                            if (charTab) charTab.remove();
                        } else {
                            console.log('[FeatureFilter] Character tab should be visible');
                        }
                    }
                    const charTabEl = document.getElementById('characterTab');
                    if (charTabEl) {
                        craftingViewEnabled = true;
                        characterViewEnabled = true;
                    } else if (poe2GemsEnabled || poe1GemsEnabled) {
                        // Even if the tab is hidden (e.g., user disables menu access), leave character view available for auto-routing.
                        characterViewEnabled = true;
                    }
                    
                    // Filter Items submenu items (version-aware: check poe1Items for PoE1, items for PoE2)
                    const itemsConfig = overlayVersionMode === 'poe1' ? enabledFeatures.poe1Items : enabledFeatures.items;
                    
                    if (itemsConfig && !itemsConfig.enabled) {
                        const itemsTab = document.getElementById('itemsTab');
                        if (itemsTab) itemsTab.remove();
                    } else if (itemsConfig?.enabled) {
                        const itemsMenu = document.getElementById('itemsMenu');
                        const subs = itemsConfig.subcategories || {};
                        let anySubEnabled = false;
                        const enabledItemActions = [];
                        
                        if (itemsMenu) {
                            const items = itemsMenu.querySelectorAll('.items-menu-item');
                            items.forEach(item => {
                                const action = item.getAttribute('data-action');
                                let shouldShow = false;
                                
                                if (action === 'uniques' && subs.uniques) shouldShow = true;
                                if (action === 'bases' && subs.bases) shouldShow = true;
                                
                                if (shouldShow) {
                                    anySubEnabled = true;
                                    item.style.display = '';
                                    if (action) enabledItemActions.push(action);
                                } else {
                                    item.style.display = 'none';
                                }
                            });
                        }
                        
                        // Hide entire Items tab if no subcategories enabled
                        if (!anySubEnabled) {
                            const itemsTab = document.getElementById('itemsTab');
                            if (itemsTab) itemsTab.remove();
                        } else {
                            const itemsTab = document.getElementById('itemsTab');
                            if (itemsTab) {
                                if (enabledItemActions.length === 1) {
                                    itemsTab.setAttribute('data-single-action', enabledItemActions[0]);
                                    const labelSpan = itemsTab.querySelector('.tab-label');
                                    if (labelSpan) labelSpan.textContent = 'Items';
                                } else {
                                    itemsTab.removeAttribute('data-single-action');
                                    const labelSpan = itemsTab.querySelector('.tab-label');
                                    if (labelSpan) labelSpan.textContent = 'Items â–¾';
                                }
                            }
                        }
                    }
                    if (document.getElementById('itemsTab')) craftingViewEnabled = true;
                    
                    // Tools menu
                    const toolsRaw = enabledFeatures.tools;
                    const toolsConfig = (toolsRaw && typeof toolsRaw === 'object') ? toolsRaw : { enabled: !!toolsRaw, subcategories: {} };
                    let toolsAnyEnabled = false;
                    
                    console.log('[FeatureFilter] Tools config:', {
                        raw: toolsRaw,
                        config: toolsConfig,
                        mode: overlayVersionMode
                    });
                    
                    if (!toolsConfig.enabled) {
                        console.log('[FeatureFilter] Tools not enabled, removing tab');
                        const toolsTab = document.getElementById('toolsTab');
                        if (toolsTab) toolsTab.remove();
                    } else {
                        const toolsMenu = document.getElementById('toolsMenu');
                        const subs = toolsConfig.subcategories || {};
                        const poe1Mode = overlayVersionMode === 'poe1';
                        let anySubEnabled = false;

                        console.log('[FeatureFilter] Tools subcategories:', subs);

                        if (toolsMenu) {
                            const items = toolsMenu.querySelectorAll('.tools-menu-item');
                            items.forEach(item => {
                                const action = item.getAttribute('data-action');
                                let shouldShow = false;

                                if (action === 'regex') {
                                    shouldShow = !poe1Mode && !!subs.regex;
                                } else if (action === 'poe1-regex') {
                                    shouldShow = poe1Mode && !!subs.poe1Regex;
                                } else if (action === 'poe1-vorici') {
                                    shouldShow = poe1Mode && !!subs.poe1Vorici;
                                }

                                console.log('[FeatureFilter] Tools item:', {
                                    action,
                                    shouldShow,
                                    poe1Mode,
                                    subs
                                });

                                if (shouldShow) {
                                    anySubEnabled = true;
                                    item.style.display = '';
                                } else {
                                    item.style.display = 'none';
                                }
                            });
                        }

                        console.log('[FeatureFilter] Any tools sub enabled:', anySubEnabled);

                        // Hide entire Tools tab if no subcategories enabled
                        if (!anySubEnabled) {
                            console.log('[FeatureFilter] No tools subs enabled, removing tab');
                            const toolsTab = document.getElementById('toolsTab');
                            if (toolsTab) toolsTab.remove();
                        } else {
                            console.log('[FeatureFilter] Tools tab should be visible');
                        }

                        toolsAnyEnabled = anySubEnabled;
                    }
                    if (document.getElementById('toolsTab')) craftingViewEnabled = true;

                    overlayHasAnyFeatures = modifiersEnabled || craftingViewEnabled || characterViewEnabled || historyEnabled;

                    setFeatureAvailability({
                        modifiers: modifiersEnabled,
                        crafting: craftingViewEnabled,
                        character: characterViewEnabled,
                        history: historyEnabled,
                        tools: toolsAnyEnabled
                    });

                    if (overlayHasAnyFeatures) {
                        // Set first visible tab as active and default view when something is available
                        const tabOrder = ['tabModifier', 'craftingTab', 'characterTab', 'itemsTab', 'toolsTab', 'tabHistory'];
                        let firstVisibleTab = null;
                        for (const tabId of tabOrder) {
                            const tab = document.getElementById(tabId);
                            if (tab && window.getComputedStyle(tab).display !== 'none') {
                                firstVisibleTab = tabId;
                                break;
                            }
                        }
                        if (firstVisibleTab) {
                            const targetView = firstVisibleTab === 'tabModifier' ? 'modifiers'
                                              : firstVisibleTab === 'tabHistory' ? 'history'
                                              : 'crafting';
                            try { setView(targetView); } catch {}
                            try { setActiveTab(firstVisibleTab); } catch {}
                            if (firstVisibleTab === 'tabHistory') {
                                try { setHeader('Merchant History'); } catch {}
                            } else if (firstVisibleTab === 'tabModifier') {
                                try { setHeader('Modifier'); } catch {}
                            } else {
                                try { setHeader('Crafting'); } catch {}
                            }
                        }
                    } else {
                        closeAllMenus();
                        setControlPanelVisible(false);
                        hideHistoryView();
                    }

                    applyOverlayVersionMode(overlayVersionMode);
                }
            } catch (err) {
                console.error('[Tab visibility] Error:', err);
            }
            
            if (overlayHasAnyFeatures) {
                try { await populateCategoryDropdown(); } catch {}
                // Re-populate once modifiers fully loaded (ensures full category list when opening without item)
                try {
                    window.electronAPI?.onModifiersLoaded?.((_cats)=> {
                        populateCategoryDropdown().catch((err)=> console.warn('[onModifiersLoaded] populateCategoryDropdown failed', err));
                    });
                } catch {}
            }
            if (overlayHasAnyFeatures && (!headerTitleEl || !headerTitleEl.textContent)) {
                const fallbackView = pickFirstAvailableView('modifiers');
                if (fallbackView === 'history') {
                    setHeader('Merchant History');
                } else if (fallbackView === 'crafting') {
                    setHeader('Crafting');
                } else {
                    setHeader('Modifier');
                }
            }
            // Initial UI state (tab already set above based on enabled features)
            try { closeAllMenus(); } catch {}
            const select = document.getElementById('categorySelect');
            if (select) {
                select.addEventListener('change', () => {
                    syncCategorySelectAppearance();
                    switchCategory();
                });
            }
            const { button: categoryButton } = getCategoryDropdownElements();
            if (categoryButton) {
                categoryButton.addEventListener('click', (event) => {
                    event.preventDefault();
                    event.stopPropagation();
                    toggleCategoryMenu();
                });
            }
            document.addEventListener('click', (event) => {
                const { wrapper } = getCategoryDropdownElements();
                if (!wrapper) return;
                if (!wrapper.contains(event.target)) {
                    closeCategoryMenu();
                }
            });
            document.addEventListener('keydown', (event) => {
                if (event.key === 'Escape') {
                    closeCategoryMenu();
                }
            });
            // Header actions
            if (closeBtn) closeBtn.addEventListener('click', ()=>{ try { window.electronAPI?.hideOverlay?.(); } catch {} });
            function updatePinUI(pinned){ if (!pinBtn) return; pinBtn.classList.toggle('active', !!pinned); pinBtn.textContent = pinned ? 'Pinned' : 'Pin'; }
            if (pinBtn) pinBtn.addEventListener('click', ()=>{ try { const isPinned = pinBtn.classList.contains('active'); window.electronAPI?.setPinned?.(!isPinned); updatePinUI(!isPinned); } catch {} });
            try { window.electronAPI?.onPinnedChanged?.((p)=> updatePinUI(p)); } catch {}
            if (settingsBtn) settingsBtn.addEventListener('click', ()=>{
                try { window.electronAPI?.openSettings?.(); } catch {}
            });
            if (updateBadgeBtn) updateBadgeBtn.addEventListener('click', ()=>{
                try {
                    if (window.electronAPI?.openReleasesPage) {
                        window.electronAPI.openReleasesPage();
                    } else {
                        window.open(UPDATE_RELEASE_URL, '_blank', 'noopener');
                    }
                } catch {
                    try { window.open(UPDATE_RELEASE_URL, '_blank', 'noopener'); } catch {}
                }
            });
            
            const modeToApply = pendingOverlayVersionMode || overlayVersionMode;
            applyOverlayVersionMode(modeToApply);
            pendingOverlayVersionMode = null;

            // Notify main process that overlay is ready (this will trigger pinned state sync)
            try { window.electronAPI?.overlayReady?.(); } catch {}
            setTimeout(()=>{ try { triggerStartupUpdateCheck(); } catch {} }, 1200);
            
            // Font size management - robust scaling for all inline px fonts
            (async function() {
                try {
                    if (!window.electronAPI) return;

                    const STATE = {
                        scale: 1,
                        scaledAttr: 'data-font-scaled'
                    };

                    function isTextual(el){
                        const tag = el.tagName;
                        if (!tag) return false;
                        return !(
                            tag === 'IMG' || tag === 'SVG' || tag === 'CANVAS' ||
                            tag === 'VIDEO' || tag === 'AUDIO' ||
                            tag === 'INPUT' || tag === 'TEXTAREA' || tag === 'SELECT'
                        );
                    }

                    function hasScaledAncestor(el){
                        try {
                            let p = el.parentElement;
                            while (p && p !== document.body){
                                if (p.getAttribute && p.getAttribute(STATE.attr)) return true;
                                p = p.parentElement;
                            }
                        } catch {}
                        return false;
                    }

                    // Find nearest ancestor that we previously marked with a stored base font
                    function nearestScaledAncestor(el){
                        try {
                            let p = el.parentElement;
                            while (p && p !== document.body){
                                if (p.getAttribute && p.getAttribute(STATE.attr)) return p;
                                p = p.parentElement;
                            }
                        } catch {}
                        return null;
                    }

                    function scaleElement(el, scale){
                        if (!isTextual(el)) return;
                        try {
                            let base = el.getAttribute(STATE.attr);
                            if (!base){
                                const cs = getComputedStyle(el);
                                let px = parseFloat(cs.fontSize) || 12;
                                // If an ancestor was already scaled and this element doesn't have its own inline font-size
                                // then its computed font-size already includes the ancestor scale. Normalize it out so we don't square the scale.
                                const hasInline = !!(el && el.style && el.style.fontSize);
                                if (!hasInline) {
                                    const anc = nearestScaledAncestor(el);
                                    if (anc) {
                                        const ancPx = parseFloat(getComputedStyle(anc).fontSize) || 0;
                                        const elPxNow = px;
                                        // Only normalize if element appears to inherit ancestor size (computed sizes are effectively equal)
                                        if (Math.abs(elPxNow - ancPx) < 0.5) {
                                            px = elPxNow / (STATE.scale || 1);
                                        }
                                    }
                                }
                                // Detect headline-like text (names/titles): heavy weight and larger base size
                                const fwRaw = (cs.fontWeight || '').toString();
                                const fw = /bold/i.test(fwRaw) ? 700 : (parseInt(fwRaw, 10) || 400);
                                const isHeadline = (fw >= 600 && px >= 13) || px >= 14;
                                el.setAttribute(STATE.attr, String(px));
                                if (isHeadline) el.setAttribute('data-font-headline', '1');
                                base = String(px);
                            }
                            const basePx = parseFloat(base) || 12;
                            // Apply sublinear scaling to headline-like text to avoid oversized names
                            const isHeadline = el.getAttribute('data-font-headline') === '1';
                            const effScale = isHeadline ? (1 + (scale - 1) * 0.6) : scale;
                            let newPx = Math.round(basePx * effScale);
                            if (!isFinite(newPx) || newPx < 8) newPx = 8;
                            // Optional soft cap to avoid runaway titles
                            if (isHeadline && newPx > 22) newPx = 22;
                            el.style.fontSize = newPx + 'px';
                            // Mark as scaled so we can safely reset only our own inline sizes later
                            el.setAttribute(STATE.scaledAttr, '1');
                        } catch {}
                    }

                    function applyScale(root, scale){
                        if (!root) root = document.body;
                        // Do not scale the root container to avoid inheritance compounding
                        // All descendants
                        const walker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT);
                        let node;
                        while ((node = walker.nextNode())){
                            scaleElement(node, scale);
                        }
                    }

                    // One-time purge of previously inlined font sizes to establish a clean baseline
                    function purgeFontState(){
                        try {
                            const walker = document.createTreeWalker(document.body, NodeFilter.SHOW_ELEMENT);
                            let node;
                            while ((node = walker.nextNode())){
                                if (node.nodeType === 1){
                                    // Only reset sizes that we previously applied; preserve original inline font-sizes
                                    if (node.getAttribute && node.getAttribute(STATE.scaledAttr) === '1'){
                                        if (node.style && node.style.fontSize) node.style.fontSize = '';
                                    }
                                    if (node.removeAttribute){
                                        node.removeAttribute(STATE.attr);
                                        node.removeAttribute(STATE.scaledAttr);
                                    }
                                }
                            }
                        } catch {}
                    }

                    // Observe dynamic content and scale newcomers using stored base
                    let observer;
                    function ensureObserver(){
                        try {
                            if (observer) return;
                            observer = new MutationObserver((mutations)=>{
                                for (const m of mutations){
                                    m.addedNodes && m.addedNodes.forEach(n=>{
                                        if (n.nodeType === 1){
                                            applyScale(n, STATE.scale);
                                        }
                                    });
                                }
                            });
                            observer.observe(document.body, { childList: true, subtree: true });
                        } catch {}
                    }

                    function setFontScale(percent){
                        const scale = Math.max(0.8, Math.min(1.5, (Number(percent)||100) / 100));
                        STATE.scale = scale;
                        applyScale(document.body, scale);
                        ensureObserver();
                        console.log('[FontSize] Applied scale:', percent + '% =>', scale);
                    }

                    // Initial load: purge inline sizes once, then set scale
                    purgeFontState();
                    const size = await window.electronAPI.getFontSize();
                    setFontScale(size);

                    // Live changes from Settings window
                    window.electronAPI.onFontSizeChanged((size) => setFontScale(size));
                } catch (e) {
                    console.warn('[FontSize] Error:', e);
                }
            })();
            
            const search = document.getElementById('search-input');
            if (search) search.addEventListener('input', () => { if (window.originalData) try { renderFilteredContent(window.originalData); } catch {} });
            // iLvl filters (debounced 500ms)
            const ilvlMinEl = document.getElementById('ilvl-min');
            const ilvlMaxEl = document.getElementById('ilvl-max');
            let ilvlDebounce = null;
            function queueIlvlFilter(){
                if (ilvlDebounce) clearTimeout(ilvlDebounce);
                ilvlDebounce = setTimeout(()=>{ if(window.originalData) try { renderFilteredContent(window.originalData); } catch {} }, 500);
            }
            if (ilvlMinEl) ilvlMinEl.addEventListener('input', queueIlvlFilter);
            if (ilvlMaxEl) ilvlMaxEl.addEventListener('input', queueIlvlFilter);
            const clear = document.getElementById('clearFilters');
            if (clear) clear.addEventListener('click', () => {
                const s = document.getElementById('search-input'); if (s) s.value = '';
                try { window.OverlayModifiers?.clearAllFilters?.(); } catch {}
                // Auto-select "All" toggle
                const toggleAll = document.getElementById('toggleAll');
                if (toggleAll && !toggleAll.classList.contains('active')) {
                    allDomainButtonIds.forEach(id => {
                        const btn = document.getElementById(id);
                        if (btn) btn.classList.remove('active');
                    });
                    toggleAll.classList.add('active');
                }
                if (window.originalData) try { renderFilteredContent(window.originalData); } catch {}
            });
            
            // Domain toggle buttons are now rendered dynamically via renderDomainToggles()
            // called from applyOverlayVersionMode()
            
            // Default view: use single source of truth
            setView('modifiers');
            // Wire clipboard item detection to auto-open correct category
            if (window.electronAPI && typeof window.electronAPI.onItemData === 'function') {
                window.electronAPI.onItemData(async (data) => {
                    try {
                        if (!data || !data.item) return;
                        // Always start from a clean state
                        closeAllMenus();

                        const item = data.item || {};
                        const rarity = (item.rarity || '').toLowerCase();
                        const name = item.name || '';
                        const baseType = item.baseType || '';
                        const category = (item.category || '').toString();
                        const blob = `${name} ${baseType} ${category}`.toLowerCase();
                        const frameType = String(item && item.frameType || '');
                        const icon = String(item && item.icon || '');

                        console.log('Clipboard item detected:', {
                            rarity: rarity,
                            name: name,
                            baseType: baseType,
                            category: category,
                            frameType: frameType,
                            icon: icon,
                            isUnique: data.isUnique,
                            itemClass: item.itemClass || 'unknown',
                            fullBlob: blob
                        });

                        // Small helper: prepare crafting view and run a show() with a couple retries
                        const prepareCrafting = (headerTitle, tabId = 'craftingTab') => {
                            setActiveTab(tabId);
                            setView('crafting');
                            setHeader(headerTitle || '');
                            recordHeaderAction(headerTitle || '');
                        };
                        const retryShow = (readyFn, runFn, attempts = 3) => {
                            if (readyFn()) { try { runFn(); } catch {} return; }
                            if (attempts <= 0) return;
                            setTimeout(() => retryShow(readyFn, runFn, attempts - 1), 120);
                        };

                        const normalizedCategory = String(category || '').toLowerCase();
                        const itemClass = (item.itemClass || '').toLowerCase();
                        const isEssence = normalizedCategory === 'essences' ||
                                           (!normalizedCategory && itemClass.includes('stackable currency') &&
                                            (/essence/i.test(name) || /essence/i.test(baseType) || /essences?/i.test(blob)));
                        const isOmen = /omen/i.test(blob);
                        const isCatalyst = /catalyst/i.test(blob);
                        // Socketables exclude Waystones now; handle Waystones separately so they stay in Modifiers
                        const isSocketable = /socketable|socketables/i.test(blob);
                        const isWaystone = /waystone|waystones/i.test(blob) || /^Waystones?_?/i.test(category || '');
                        // Fix: Liquid Emotions detection - check category first, then fallback to name/baseType containing "liquid"
                        const isEmotion = normalizedCategory === 'liquid_emotions' || /liquid/i.test(name) || /liquid/i.test(baseType);
                        // Fix: Gems should route to Character > Gems - use itemClass instead of text matching to avoid false positives with "spirit" in rare item names
                        const isGem = itemClass.includes('skill gem') || itemClass.includes('spirit gem') || itemClass.includes('uncut spirit gem') || itemClass.includes('support gem');
                        const isPoe1Mode = overlayVersionMode === 'poe1';
                        const isPoe1Scarabs = isPoe1Mode && (normalizedCategory === 'scarabs' || /scarab/i.test(blob));
                        const isPoe1Fossils = isPoe1Mode && (normalizedCategory === 'fossils' || /fossil/i.test(blob));
                        const isPoe1Runegrafts = isPoe1Mode && (normalizedCategory === 'runegrafts' || /runegraft/i.test(blob));
                        const isPoe1Horticrafting = isPoe1Mode && (normalizedCategory === 'horticrafting' || /crystallised lifeforce|lifeforce/i.test(blob) || /horticrafting/i.test(blob));
                        // Beast detection: Stackable Currency + typical beast name patterns (Farric/Fenumal/Saqawine/Craicic + creature type)
                        const isPoe1Bestiary = isPoe1Mode && itemClass.includes('stackable currency') && /\b(farric|fenumal|saqawine|craicic)\s+/i.test(baseType);
                        const isPoe1Allflames = isPoe1Mode && (normalizedCategory === 'embers' || /allflame|ember/i.test(blob));
                        const isPoe1Essence = isPoe1Mode && isEssence;
                        const isPoe1Currency = isPoe1Mode && !isPoe1Scarabs && !isPoe1Fossils && !isPoe1Runegrafts && !isPoe1Horticrafting && !isPoe1Bestiary && !isPoe1Allflames && !isPoe1Essence && (
                            normalizedCategory === 'currency' ||
                            ((itemClass.includes('stackable currency') || itemClass.includes('currency')) && /orb|scroll|bauble|whetstone|chisel|fusing|jeweller|chromatic|binding|annul|mirror|regret|exalted|chaos|splinter|fragment|sextant|compass|coin|prism|catalyst|harvest|fossil|resonator|blessing|prophecy|favour|perandus|remnant|ancient/i.test(blob))
                        );
                        const isPoe1DivinationCard = isPoe1Mode && (normalizedCategory === 'divination_cards' || itemClass.includes('divination card') || blob.includes('divination card'));
                        const socketsPoe1 = Array.isArray(item?.socketsPoe1) ? item.socketsPoe1 : null;
                        const totalSocketsPoe1 = socketsPoe1 ? socketsPoe1.flat().filter(Boolean).length : 0;
                        const voriciMenuItem = document.querySelector('#toolsMenu .tools-menu-item[data-action="poe1-vorici"]');
                        const voriciFeatureEnabled = !!voriciMenuItem && window.getComputedStyle(voriciMenuItem).display !== 'none';
                        const voriciAutoEligible = isPoe1Mode && voriciFeatureEnabled && totalSocketsPoe1 > 0;
                        const voriciSocketedItems = Array.isArray(item?.socketedItems) ? item.socketedItems : [];

                        // Store Vorici data if eligible (regardless of item type - uniques can be colored too!)
                        if (voriciAutoEligible) {
                            window.pendingVoriciData = {
                                item,
                                socketsPoe1,
                                socketedItems: voriciSocketedItems,
                                requirements: item.requirements || {},
                                quality: item.quality,
                                name,
                                baseType
                            };
                            console.log('Stored Vorici data for item with sockets:', totalSocketsPoe1);
                        }

                        // Route checks - order matters!
                        // Hard rule: Handle unique items first - use simple text detection like essences
                        const isUnique = /unique/i.test(name) || /unique/i.test(baseType) || /unique/i.test(blob) || 
                                        data.isUnique || /unique/i.test(rarity) || frameType === '3' || String(frameType) === '3' ||
                                        /\bUniques\//i.test(icon);

                        if (isUnique) {
                            console.log('Unique item detected:', {
                                name: name,
                                baseType: baseType,
                                hasVoriciData: !!window.pendingVoriciData
                            });
                            // Uniques page is PoE2-only for now
                            if (overlayVersionMode === 'poe2') {
                                prepareCrafting('Uniques', 'itemsTab');
                                retryShow(
                                    () => !!(window.OverlayUniques && typeof window.OverlayUniques.show === 'function'),
                                    async () => {
                                        try { await showUniques(); } catch {}
                                    }
                                );
                            } else {
                                // PoE1 mode - just open overlay on last visited page (Modifiers)
                                console.log('Unique copied in PoE1 mode - opening on last page (Vorici data stored if has sockets)');
                                setActiveTab('tabModifier');
                                setView('modifiers');
                                setHeader('Modifier');
                            }
                            return;
                        }

                        if (isEssence) {
                            if (overlayVersionMode === 'poe2') {
                                prepareCrafting('Essences');
                                retryShow(
                                    () => !!(window.OverlayEssences && typeof window.OverlayEssences.show === 'function'),
                                    async () => { try { await showEssences(); } catch {} }
                                );
                            } else {
                                prepareCrafting('PoE1 Essences');
                                retryShow(
                                    () => !!(window.OverlayPoe1Essences && typeof window.OverlayPoe1Essences.show === 'function'),
                                    async () => { try { await showPoe1Essences(); } catch {} }
                                );
                            }
                            return;
                        }

                        if (isOmen) {
                            // Omens page is PoE2-only
                            if (overlayVersionMode === 'poe2') {
                                prepareCrafting('Omens');
                                retryShow(
                                    () => !!(window.OverlayOmens && typeof window.OverlayOmens.show === 'function'),
                                    async () => { try { await showOmens(); } catch {} }
                                );
                            } else {
                                console.log('Omen copied in PoE1 mode - opening on last page');
                                setActiveTab('tabModifier');
                                setView('modifiers');
                                setHeader('Modifier');
                            }
                            return;
                        }

                        if (isCatalyst) {
                            // Catalysts page is PoE2-only
                            if (overlayVersionMode === 'poe2') {
                                prepareCrafting('Catalysts');
                                retryShow(
                                    () => !!(window.OverlayCatalysts && typeof window.OverlayCatalysts.show === 'function'),
                                    async () => { try { await showCatalysts(); } catch {} }
                                );
                            } else {
                                console.log('Catalyst copied in PoE1 mode - opening on last page');
                                setActiveTab('tabModifier');
                                setView('modifiers');
                                setHeader('Modifier');
                            }
                            return;
                        }

                        if (isSocketable) {
                            // Socketables page is PoE2-only
                            if (overlayVersionMode === 'poe2') {
                                prepareCrafting('Socketables');
                                retryShow(
                                    () => !!(window.OverlaySocketables && typeof window.OverlaySocketables.show === 'function'),
                                    async () => { try { await showSocketables(); } catch {} }
                                );
                            } else {
                                console.log('Socketable copied in PoE1 mode - opening on last page');
                                setActiveTab('tabModifier');
                                setView('modifiers');
                                setHeader('Modifier');
                            }
                            return;
                        }

                        if (isPoe1Scarabs) {
                            prepareCrafting('PoE1 Scarabs');
                            retryShow(
                                () => !!(window.OverlayPoe1Scarabs && typeof window.OverlayPoe1Scarabs.show === 'function'),
                                async () => { try { await showPoe1Scarabs(); } catch {} }
                            );
                            return;
                        }

                        if (isPoe1Fossils) {
                            prepareCrafting('PoE1 Fossils');
                            retryShow(
                                () => !!(window.OverlayPoe1Fossils && typeof window.OverlayPoe1Fossils.show === 'function'),
                                async () => { try { await showPoe1Fossils(); } catch {} }
                            );
                            return;
                        }

                        if (isPoe1Runegrafts) {
                            prepareCrafting('PoE1 Runegrafts');
                            retryShow(
                                () => !!(window.OverlayPoe1Runegrafts && typeof window.OverlayPoe1Runegrafts.show === 'function'),
                                async () => { try { await showPoe1Runegrafts(); } catch {} }
                            );
                            return;
                        }

                        if (isPoe1Horticrafting) {
                            prepareCrafting('PoE1 Horticrafting');
                            retryShow(
                                () => !!(window.OverlayPoe1Horticrafting && typeof window.OverlayPoe1Horticrafting.show === 'function'),
                                async () => { try { await showPoe1Horticrafting(); } catch {} }
                            );
                            return;
                        }

                        if (isPoe1Bestiary) {
                            prepareCrafting('PoE1 Bestiary');
                            retryShow(
                                () => !!(window.OverlayPoe1Bestiary && typeof window.OverlayPoe1Bestiary.show === 'function'),
                                async () => { try { await showPoe1Bestiary(); } catch {} }
                            );
                            return;
                        }

                        if (isPoe1Allflames) {
                            prepareCrafting('PoE1 Allflames');
                            retryShow(
                                () => !!(window.OverlayPoe1Embers && typeof window.OverlayPoe1Embers.show === 'function'),
                                async () => { try { await showPoe1Embers(); } catch {} }
                            );
                            return;
                        }

                        if (isPoe1Currency) {
                            prepareCrafting('PoE1 Currency');
                            retryShow(
                                () => !!(window.OverlayPoe1Currency && typeof window.OverlayPoe1Currency.show === 'function'),
                                async () => { try { await showPoe1Currency(); } catch {} }
                            );
                            return;
                        }

                        if (isWaystone) {
                            // Waystones are PoE2-only
                            if (overlayVersionMode === 'poe2') {
                                // Keep Waystones in Modifiers tab; derive Low/Mid/Top category if provided by backend
                                setActiveTab('tabModifier');
                                setView('modifiers');
                                setHeader('Waystones');
                                // Decide variant: prefer provided category, else simple heuristic
                                let wsCat = (category || '').startsWith('Waystones_') ? category : '';
                                if (!wsCat) {
                                    // Heuristic by Area Level or Tier inside blob if needed (client side fallback)
                                    const tierMatch = blob.match(/Waystone\s*Tier\s*(\d+)/i) || name.match(/Tier\s*(\d+)/i);
                                    if (tierMatch) {
                                        const t = parseInt(tierMatch[1], 10);
                                        if (t >=1 && t <=5) wsCat = 'Waystones_Low'; else if (t<=10) wsCat = 'Waystones_Mid'; else wsCat = 'Waystones_Top';
                                    }
                                }
                                if (!wsCat) wsCat = 'Waystones_Low';
                                // Update item.category so dropdown gets set correctly below
                                item.category = wsCat;
                                // Don't return - let the normal category handling code process it
                            } else {
                                console.log('Waystone copied in PoE1 mode - opening on last page');
                                setActiveTab('tabModifier');
                                setView('modifiers');
                                setHeader('Modifier');
                                return;
                            }
                        }

                        if (isEmotion) {
                            // Liquid Emotions page is PoE2-only
                            if (overlayVersionMode === 'poe2') {
                                prepareCrafting('Liquid Emotions');
                                retryShow(
                                    () => !!(window.OverlayLiquid && typeof window.OverlayLiquid.show === 'function'),
                                    async () => { try { await showLiquidEmotions(); } catch {} }
                                );
                            } else {
                                console.log('Liquid Emotion copied in PoE1 mode - opening on last page');
                                setActiveTab('tabModifier');
                                setView('modifiers');
                                setHeader('Modifier');
                            }
                            return;
                        }

                        if (isGem) {
                            if (overlayVersionMode === 'poe2') {
                                // Route to Character > Gems directly (no crafting mode)
                                setActiveTab('characterTab');
                                setView('character');
                                retryShow(
                                    () => !!(window.OverlayGems && typeof window.OverlayGems.show === 'function'),
                                    async () => { 
                                        try { 
                                            await showGems(); 
                                            setHeader('Gems');
                                            recordHeaderAction('Gems');
                                        } catch {} 
                                    }
                                );
                            } else {
                                setActiveTab('characterTab');
                                setView('character');
                                retryShow(
                                    () => !!(window.OverlayPoe1Gems && typeof window.OverlayPoe1Gems.showList === 'function'),
                                    async () => {
                                        try {
                                            await window.OverlayPoe1Gems.showList();
                                            setHeader('Gems');
                                            recordHeaderAction('Gems');
                                        } catch {}
                                    }
                                );
                            }
                            return;
                        }

                        if (isPoe1DivinationCard) {
                            setActiveTab('characterTab');
                            setView('crafting');
                            retryShow(
                                () => !!(window.OverlayPoe1DivinationCards && typeof window.OverlayPoe1DivinationCards.show === 'function'),
                                async () => {
                                    try {
                                        await window.OverlayPoe1DivinationCards.show();
                                        setHeader('Divination Cards');
                                        recordHeaderAction('Divination Cards');
                                    } catch {}
                                }
                            );
                            return;
                        }

                        // Store Vorici data if eligible, but don't auto-open
                        if (voriciAutoEligible) {
                            // Store data in global for later use when user manually opens Vorici
                            window.pendingVoriciData = {
                                item,
                                socketsPoe1,
                                socketedItems: voriciSocketedItems,
                                requirements: item.requirements || {},
                                quality: item.quality,
                                name,
                                baseType
                            };
                            console.log('Stored Vorici data for item with sockets:', totalSocketsPoe1);
                        }

                        // Default: Modifiers view
                        setActiveTab('tabModifier');
                        setView('modifiers');
                        await populateCategoryDropdown();
                        const categorySelect = document.getElementById('categorySelect');
                        if (categorySelect && item.category) {
                            const slug = String(item.category);
                            console.log('Looking for category option:', slug);
                            const opt = Array.from(categorySelect.options||[]).find(o=>o.value===slug);
                            console.log('Found option:', opt);
                            if (opt) { 
                                // Set dropdown value WITHOUT triggering change event (data already has modifiers)
                                categorySelect.value = slug;
                                syncCategorySelectAppearance();
                                console.log('Set category dropdown to:', slug, '(no reload, using provided modifiers)');
                                markModifiersCategory(slug);
                            } else {
                                console.log('Category option not found in dropdown for:', slug);
                            }
                        }
                        // Render directly with provided modifiers (no need to reload)
                        window.originalData = data;
                        try { window.OverlayModifiers?.mechanicsPostProcess?.(data); } catch {}
                        renderFilteredContent(data);
                        setHeader('Modifier');
                    } catch (e) { console.warn('onItemData handling failed', e); }
                });
            }
        });
            if (tabMod) {
                tabMod.addEventListener('click', () => {
                    setActiveTab('tabModifier');
                    closeAllMenus();
                    setView('modifiers'); // Use single source of truth
                    document.getElementById('modifierHeaderInfo')?.setAttribute('style','');
                    document.getElementById('whittlingInfo')?.setAttribute('style','margin-left: auto; display:none; -webkit-app-region: no-drag;');
                    setControlPanelVisible(true);
                    document.body.classList.remove('crafting-mode');
                    setHeader('Modifier');
                    
                });
            }

            // Crafting dropdown toggle
            if (craftingTab) {
                craftingTab.addEventListener('click', (e) => {
                    e.stopPropagation();
                    setActiveTab('craftingTab');
                    const vis = craftingMenu.style.display === 'block';
                    closeAllMenus();
                    craftingMenu.style.display = vis ? 'none' : 'block';
                });
                window.addEventListener('click', () => { craftingMenu.style.display = 'none'; });
                craftingMenu.addEventListener('click', (e) => { e.stopPropagation(); });
                craftingMenu.querySelectorAll('.crafting-menu-item').forEach(item => {
                    item.addEventListener('click', async (e) => {
                        const action = item.getAttribute('data-action');
                        closeAllMenus();
                        if (!action) {
                            console.warn('[CraftingMenu] Click without action payload');
                            return;
                        }
                        // Reuse stored-action pipeline so PoE1/PoE2 entries share the same handling
                        const handled = await runStoredAction(`crafting:${action}`);
                        if (!handled) {
                            console.warn('[CraftingMenu] No handler resolved for crafting action', action);
                        }
                        // Ensure craftingTab remains visually active after menu closes
                        setActiveTab('craftingTab');
                    });
                });
            }

            if (loginBtn) {
                loginBtn.addEventListener('click', async () => {
                    // Check if logged in - if yes, open trade history page; if no, show login window
                    const session = await window.electronAPI.poeGetSession();
                    if (session?.loggedIn) {
                        await window.electronAPI.poeOpenHistoryWindow();
                    } else {
                        const res = await window.electronAPI.poeLogin();
                        if (res?.loggedIn) {
                            await updateSessionUI();
                            // Do not auto-refresh on login; user controls refresh explicitly
                        }
                    }
                });
            }
            // Refresh button logic now handled by modular history system (refreshButton.ts)
            // Legacy confirm() popup removed to avoid duplicate dialogs and native alert.
            // attachRefreshButtonLogic() (called in history/module.ts) wires the styled confirmation dialog.
            // We leave this block intentionally empty to prevent double-binding.
            // (If needed in future, ensure not to reintroduce native confirm here.)
            
            // History popout button
            const popoutBtn = document.getElementById('historyPopoutBtn');
            if (popoutBtn) {
                popoutBtn.addEventListener('click', async () => {
                    try {
                        if (typeof window.OverlayHistory?.onOpenPopout === 'function') {
                            await window.OverlayHistory.onOpenPopout();
                        }
                    } catch (e) {
                        console.error('Failed to open history popout:', e);
                    }
                });
            }
            
            // Chart expand button - expands chart to take full right panel space
            const chartExpandBtn = document.getElementById('chartExpandBtn');
            const historyRight = document.getElementById('historyRight');
            if (chartExpandBtn && historyRight) {
                chartExpandBtn.addEventListener('click', () => {
                    const expanded = historyRight.classList.toggle('history-chart-expanded');
                    chartExpandBtn.textContent = expanded ? 'â–¼' : 'â–²';
                    chartExpandBtn.title = expanded ? 'Show item details panel' : 'Expand chart to take full space';

                    // Trigger height adjustment and redraw
                    adjustHistoryChartHeight();
                    
                    const refresh = () => {
                        try { if (typeof drawHistoryChart === 'function') drawHistoryChart(); } catch {}
                    };

                    requestAnimationFrame(() => {
                        adjustHistoryChartHeight();
                        refresh();
                        setTimeout(() => {
                            adjustHistoryChartHeight();
                            refresh();
                        }, 120);
                    });
                });
            }
            
            if (typeof updateHistoryRefreshButton === 'function') { try { updateHistoryRefreshButton(); } catch {} }

            // History tab toggle: show history container and hide modifiers/crafting
            if (tabHist) {
                tabHist.addEventListener('click', () => {
                    setActiveTab('tabHistory');
                    closeAllMenus();
                    // Use strong view gate
                    setView('history');
                    // ensure history UI readiness
                    try { updateSessionUI(); } catch {}
                    try { if (typeof refreshHistoryIfAllowed === 'function') refreshHistoryIfAllowed('nav'); } catch {}
                    // proactively render from store before/while fetching
                    try { if (typeof renderHistoryTotals === 'function') renderHistoryTotals(); } catch {}
                    try { if (typeof renderHistoryActiveFilters === 'function') renderHistoryActiveFilters(); } catch {}
                    try { if (typeof renderHistoryList === 'function') renderHistoryList(); } catch {}
                    try { if (typeof renderHistoryDetail === 'function') renderHistoryDetail(0); } catch {}
                    // proactively compute and draw chart from last known data if available
                    try { if (typeof recomputeChartSeriesFromStore === 'function') recomputeChartSeriesFromStore(); } catch {}
                    // Draw after container becomes visible â€“ schedule multiple attempts
                    try {
                        if (typeof drawHistoryChart === 'function') {
                            drawHistoryChart(); // immediate
                            requestAnimationFrame(()=>{ try { drawHistoryChart(); } catch {} });
                            setTimeout(()=>{ try { drawHistoryChart(); } catch {} }, 50);
                            setTimeout(()=>{ try { drawHistoryChart(); } catch {} }, 150);
                            setTimeout(()=>{ try { drawHistoryChart(); } catch {} }, 300);
                        }
                    } catch {}
                    setHeader('Merchant History');
                    recordHeaderAction('Merchant History');
                    
                });
            }

            // Mask toggle feature removed (account name no longer displayed)

            // Filters UI wiring
            const minEl = document.getElementById('histMinValue');
            const maxEl = document.getElementById('histMaxValue');
            const curEl = document.getElementById('histCurrency');
            const catEl = document.getElementById('histCategory');
            const sortEl = document.getElementById('histSort');
            const rarEl = document.getElementById('histRarity');
            const timeEl = document.getElementById('histTimeframe');
            const searchEl = document.getElementById('histSearch');
            
            // Deferred filter binding: retry until OverlayHistory is actually attached & ready.
            (function bindHistoryFilters(attempt=0){
                const H = window.OverlayHistory;
                const ready = !!(H && H.historyState && typeof H.applyAndRender === 'function');
                if (!ready){
                    if (attempt === 0) console.log('[Filter Setup] OverlayHistory not ready yet â€“ deferring');
                    if (attempt < 50) return setTimeout(()=>bindHistoryFilters(attempt+1), 100); // up to 5s
                    console.warn('[Filter Setup] Gave up waiting for OverlayHistory after 5s');
                    return;
                }
                console.log('[Filter Setup] Binding filters on attempt', attempt, 'state entries:', H.historyState.store?.entries?.length||0);
                const histState = H.historyState;
                const applyAndRenderFn = H.applyAndRender;
                const wire = (el, ev, fn)=>{ if(el){ el.addEventListener(ev, fn); el.setAttribute('data-filter-wired','1'); } };
                if (minEl) minEl.value = histState.filters.min > 0 ? String(histState.filters.min) : '';
                if (maxEl) maxEl.value = histState.filters.max > 0 ? String(histState.filters.max) : '';
                if (curEl) curEl.value = histState.filters.cur || '';
                if (catEl) catEl.value = histState.filters.category || '';
                if (sortEl) sortEl.value = histState.sort || 'newest';
                if (rarEl) rarEl.value = histState.filters.rarity || '';
                if (timeEl) timeEl.value = histState.filters.timeframe || 'all';
                if (searchEl) searchEl.value = histState.filters.search || '';
                wire(minEl,'input', ()=>{ histState.filters.min = Number(minEl.value||0); applyAndRenderFn(); });
                wire(maxEl,'input', ()=>{ histState.filters.max = Number(maxEl.value||0); applyAndRenderFn(); });
                wire(curEl,'change', ()=>{ histState.filters.cur = String(curEl.value||''); applyAndRenderFn(); });
                wire(catEl,'change', ()=>{ histState.filters.category = String(catEl.value||''); applyAndRenderFn(); });
                wire(sortEl,'change', ()=>{ histState.sort = String(sortEl.value||'newest'); applyAndRenderFn(); });
                wire(rarEl,'change', ()=>{ histState.filters.rarity = String(rarEl.value||''); applyAndRenderFn(); });
                wire(timeEl,'change', ()=>{ histState.filters.timeframe = String(timeEl.value||'all'); applyAndRenderFn(); });
                wire(searchEl,'input', ()=>{ histState.filters.search = String(searchEl.value||'').trim().toLowerCase(); applyAndRenderFn(); });
                console.log('[Filter Setup] Filters wired');
            })();
        
        function setupAdaptiveBar(container, selectors){
            if (!container || typeof ResizeObserver === 'undefined') return;
            const targets = selectors
                .map(sel => typeof sel === 'string' ? container.querySelector(sel) : sel)
                .filter(el => el && el instanceof HTMLElement);
            if (!targets.length) return;

            const apply = () => {
                targets.forEach(el => el.classList.remove('auto-condensed'));
                let overflow = container.scrollWidth > container.clientWidth + 1;
                for (const el of targets){
                    if (!overflow) break;
                    el.classList.add('auto-condensed');
                    overflow = container.scrollWidth > container.clientWidth + 1;
                }
            };

            const ro = new ResizeObserver(() => apply());
            ro.observe(container);
            window.addEventListener('resize', apply);
            apply();
        }

        function setupLegendOverflow() {
            const legend = document.getElementById('chartLegend');
            const moreBtn = document.getElementById('chartLegendMore');
            if (!legend || !moreBtn) return;
            if (legend.dataset.legendEnhanced === '1') return;
            legend.dataset.legendEnhanced = '1';

            const items = Array.from(legend.querySelectorAll('.chart-cur'));
            if (!items.length) return;

            let expanded = false;
            let rafId = 0;

            const schedule = () => {
                if (expanded) return;
                if (rafId) cancelAnimationFrame(rafId);
                rafId = requestAnimationFrame(() => {
                    rafId = 0;
                    apply();
                });
            };

            function apply() {
                if (expanded) return;
                moreBtn.hidden = true;
                moreBtn.textContent = '';
                moreBtn.title = '';
                items.forEach(item => item.classList.remove('legend-condensed'));

                const baseHidden = items.filter(item => item.dataset.defaultCondensed === '1');
                baseHidden.forEach(item => item.classList.add('legend-condensed'));

                let overflow = legend.scrollWidth > legend.clientWidth + 1;
                const hidden = [];
                const hideCandidates = items
                    .filter(item => item.dataset.lock !== '1' && !baseHidden.includes(item))
                    .sort((a, b) => Number(b.dataset.priority || '999') - Number(a.dataset.priority || '999'));

                for (const item of hideCandidates) {
                    if (!overflow) break;
                    item.classList.add('legend-condensed');
                    hidden.push(item);
                    overflow = legend.scrollWidth > legend.clientWidth + 1;
                }

                if (overflow) {
                    const locked = items
                        .filter(item => item.dataset.lock === '1' && !baseHidden.includes(item))
                        .sort((a, b) => Number(b.dataset.priority || '999') - Number(a.dataset.priority || '999'));
                    for (const item of locked) {
                        if (!overflow) break;
                        item.classList.add('legend-condensed');
                        hidden.push(item);
                        overflow = legend.scrollWidth > legend.clientWidth + 1;
                    }
                }

                const totalHidden = baseHidden.concat(hidden);

                if (totalHidden.length) {
                    const tooltip = totalHidden
                        .map(item => (item.textContent || item.dataset.cur || '')?.trim())
                        .filter(Boolean)
                        .join('\n');
                    moreBtn.hidden = false;
                    moreBtn.textContent = `+${totalHidden.length}`;
                    moreBtn.title = tooltip;
                    moreBtn.dataset.tooltip = tooltip;
                } else {
                    moreBtn.hidden = true;
                    delete moreBtn.dataset.tooltip;
                }
            }

            moreBtn.addEventListener('click', () => {
                expanded = !expanded;
                moreBtn.setAttribute('aria-expanded', expanded ? 'true' : 'false');
                if (expanded) {
                    items.forEach(item => item.classList.remove('legend-condensed'));
                    moreBtn.hidden = false;
                    moreBtn.textContent = 'Show less';
                    moreBtn.title = 'Hide additional currencies';
                } else {
                    schedule();
                }
            });

            if (typeof ResizeObserver !== 'undefined') {
                const ro = new ResizeObserver(() => schedule());
                ro.observe(legend);
            }
            window.addEventListener('resize', schedule);

            schedule();
        }

        document.addEventListener('DOMContentLoaded', () => {
            setupAdaptiveBar(document.getElementById('controlPanel'), ['#ilvlControls', '#searchInputWrap', '#domainFilters', '#clearFilters']);
            setupAdaptiveBar(document.getElementById('historyHeaderRow2'), ['.grp-type', '.grp-rarity', '.grp-sort', '.grp-time']);
            setupLegendOverflow();
        });


        // ===== Crafting: Liquid Emotions (delegation only) =====
        let craftingPanelEl = null;
        async function showLiquidEmotions() {
            if (window.OverlayLiquid && window.OverlayLiquid.show) { try { return await window.OverlayLiquid.show(); } catch {} }
        }

        function hideCraftingPanel() {
            const el = document.getElementById('craftingPanel');
            if (el) el.style.display = 'none';
        }

        function hideAnnointsPanel() {
            if (window.OverlayAnnoints && window.OverlayAnnoints.hide) { try { return window.OverlayAnnoints.hide(); } catch {} }
            const el = document.getElementById('annointsPanel');
            if (el) el.style.display = 'none';
        }

        function highlightLiquidEmotion(name) {
            if (window.OverlayLiquid && window.OverlayLiquid.highlight) { try { return window.OverlayLiquid.highlight(name); } catch {} }
        }

        async function reloadLiquidEmotions() {
            if (window.OverlayLiquid && window.OverlayLiquid.reload) { try { return await window.OverlayLiquid.reload(); } catch {} }
        }

        // History functions are delegated above; fallbacks removed

        // History implementation moved to module

        // History fallback moved to module

        // ===== Simple totals chart (canvas, no external deps) =====
    // Redraw on resize using module's chart
        function adjustHistoryChartHeight(){
            try {
                const right = document.getElementById('historyRight');
                const detail = document.getElementById('historyDetail');
                const wrap = document.getElementById('historyChartWrap');
                if (!right || !detail || !wrap) return;

                const expanded = right.classList.contains('history-chart-expanded');
                const collapsed = wrap.classList.contains('chart-collapsed');

                // Always enforce an 8px gap above the chart in normal mode; remove in expanded/collapsed
                const GAP = 8;
                if (collapsed) {
                    // Hide body via class; let flex naturally size
                    detail.style.marginBottom = '';
                    wrap.style.flex = '0 0 auto';
                    wrap.style.height = '';
                    return;
                }

                if (expanded) {
                    // Chart takes all vertical space; remove gap and let flex grow
                    detail.style.marginBottom = '';
                    wrap.style.flex = '1 1 auto';
                    wrap.style.height = '';
                    return;
                }

                // Normal mode: detail sits on top, chart flexes to fill the rest; dock naturally
                detail.style.marginBottom = GAP + 'px';
                wrap.style.flex = '1 1 auto';
                wrap.style.height = '';
            } catch {}
        }

        window.addEventListener('resize', ()=> { try { adjustHistoryChartHeight(); drawHistoryChart(); } catch {} });
    // Draw again after a brief delay to handle first-layout canvas sizes
    document.addEventListener('DOMContentLoaded', ()=>{ setTimeout(()=>{ try { adjustHistoryChartHeight(); drawHistoryChart(); } catch {} }, 50); });
        // Observe visibility/size changes on the historyRight container
        document.addEventListener('DOMContentLoaded', ()=>{
            const right = document.getElementById('historyRight');
            if (!right || typeof MutationObserver === 'undefined') return;
            const obs = new MutationObserver(()=>{ try { adjustHistoryChartHeight(); drawHistoryChart(); } catch {} });
            obs.observe(right, { attributes:true, attributeFilter:['style','class'] });
        });
        // Also observe actual size changes of the chart wrapper if supported
        document.addEventListener('DOMContentLoaded', ()=>{
            try {
                const wrap = document.getElementById('historyChartWrap');
                const right = document.getElementById('historyRight');
                const detail = document.getElementById('historyDetail');
                if (typeof ResizeObserver !== 'undefined') {
                    if (wrap) {
                        const ro = new ResizeObserver(() => { try { adjustHistoryChartHeight(); drawHistoryChart(); } catch {} });
                        ro.observe(wrap);
                    }
                    if (right) {
                        const ro2 = new ResizeObserver(() => { try { adjustHistoryChartHeight(); drawHistoryChart(); } catch {} });
                        ro2.observe(right);
                    }
                    if (detail) {
                        const ro3 = new ResizeObserver(() => { try { adjustHistoryChartHeight(); drawHistoryChart(); } catch {} });
                        ro3.observe(detail);
                    }
                }
            } catch {}
        });
        // Legend click handlers: delegate to module
        document.addEventListener('DOMContentLoaded', ()=>{
            const els = [
                document.getElementById('chartCur-divine'),
                document.getElementById('chartCur-exalted'),
                document.getElementById('chartCur-annul'),
                document.getElementById('chartCur-chaos'),
                document.getElementById('chartCur-regal')
            ].filter(Boolean);
            els.forEach(el=>{
                el.addEventListener('click', ()=>{
                    const cur = el.getAttribute('data-cur')||'divine';
                    try { setChartCurrency(cur); } catch {}
                    els.forEach(e=> e.classList.toggle('active', e===el));
                    drawHistoryChart();
                });
            });

            // Chart collapse/expand handler
            const collapseBtn = document.getElementById('chartCollapseBtn');
            const chartWrap = document.getElementById('historyChartWrap');
            const chartBody = document.getElementById('historyChartBody');
            const chartCanvas = document.getElementById('historyChart');
            let chartCollapsed = localStorage.getItem('historyChartCollapsed') === 'true';

            const applyChartCollapsed = (collapsed) => {
                if (!chartWrap) return;
                chartWrap.classList.toggle('chart-collapsed', collapsed);
                if (chartBody) {
                    chartBody.style.display = collapsed ? 'none' : 'flex';
                }
                if (chartCanvas) {
                    chartCanvas.style.display = collapsed ? 'none' : 'block';
                }
                if (collapseBtn) {
                    collapseBtn.textContent = collapsed ? 'â–¶' : 'â–¼';
                    collapseBtn.title = collapsed ? 'Expand chart' : 'Collapse chart';
                }
                // Always adjust after state change
                setTimeout(() => adjustHistoryChartHeight(), 10);
                if (!collapsed) {
                    const triggerRedraw = () => { try { drawHistoryChart(); } catch {} };
                    requestAnimationFrame(triggerRedraw);
                    setTimeout(triggerRedraw, 140);
                }
            };

            applyChartCollapsed(chartCollapsed);

            if (collapseBtn) {
                collapseBtn.addEventListener('click', () => {
                    chartCollapsed = !chartCollapsed;
                    localStorage.setItem('historyChartCollapsed', chartCollapsed.toString());
                    applyChartCollapsed(chartCollapsed);
                });
            }
        });

        // Throttle helpers and button state management
        // Rate limit helpers delegated to module

        // History list/detail/time delegates live in module

        function escapeHtml(str) {
            if (window.OverlayUtils && window.OverlayUtils.escapeHtml) {
                try { return window.OverlayUtils.escapeHtml(str); } catch {}
            }
            if (str == null) return '';
            return String(str)
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#39;');
        }

        // Normalize currency labels to canonical keys used across filters/totals/UI
        function normalizeCurrency(c) {
            if (window.OverlayUtils && window.OverlayUtils.normalizeCurrency) {
                try { return window.OverlayUtils.normalizeCurrency(c); } catch {}
            }
            const raw = (c || '').toString().toLowerCase().trim();
            if (!raw) return '';
            // common shorthands and plurals
            const s = raw
                .replace(/\borbs?\b/g, '')
                .replace(/\borb\b/g, '')
                .replace(/\s+/g, ' ')
                .trim();
            if (/^(ex|exa|exalt|exalted)/.test(s)) return 'exalted';
            if (/^(div|divi|divine)/.test(s)) return 'divine';
            if (/^(ann|annul|annulment)/.test(s)) return 'annul';
            if (/^(c|chaos)/.test(s)) return 'chaos';
            if (/altar/.test(s)) return 'altar';
            return s;
        }

        // Delegations for modifier helpers now in module
        const _origCreateModItem = window.createModItem;
        if (typeof _origCreateModItem === 'function') {
          try { window.OverlayModifiers?.patchCreateModItem?.(); } catch {}
        }

// Character menu wiring
document.addEventListener('DOMContentLoaded', () => {
        if (characterTab) {
        characterTab.addEventListener('click', (e) => {
            e.stopPropagation();
                setActiveTab('characterTab');
                const vis = characterMenu && characterMenu.style.display === 'block';
                closeAllMenus();
                if (characterMenu) characterMenu.style.display = vis ? 'none' : 'block';
        });
        window.addEventListener('click', () => { if (characterMenu) characterMenu.style.display = 'none'; });
        if (characterMenu) characterMenu.addEventListener('click', (e) => { e.stopPropagation(); });
        if (characterMenu) characterMenu.querySelectorAll('.character-menu-item').forEach(item => {
            item.addEventListener('click', async () => {
                setActiveTab('characterTab');
                closeAllMenus();
                const action = item.getAttribute('data-action');
                if (characterMenu) characterMenu.style.display = 'none';
                // Switch to character view using single source of truth
                setView('character');
                if (action === 'quest-passives') {
                    if (window.OverlayQuestPassives?.show) { try { await window.OverlayQuestPassives.show(); } catch {} }
                    setHeader('Quest Passives');
                    recordHeaderAction('Quest Passives');
                    
                } else if (action === 'keystones') {
                    await showKeystones();
                    setHeader('Keystones');
                    recordHeaderAction('Keystones');
                    
                } else if (action === 'asc-passives') {
                    await showAscendancyPassives();
                    setHeader('Ascendancy Passives');
                    recordHeaderAction('Ascendancy Passives');
                    
                } else if (action === 'atlas-nodes') {
                    await showAtlasNodes();
                    setHeader('Atlas Nodes');
                    recordHeaderAction('Atlas Nodes');
                } else if (action === 'gems') {
                    await showGems();
                    setHeader('Gems');
                    recordHeaderAction('Gems');
                } else if (action === 'poe1-divination-cards') {
                    if (window.OverlayPoe1DivinationCards?.show) { try { await window.OverlayPoe1DivinationCards.show(); } catch {} }
                    setHeader('Divination Cards');
                    recordHeaderAction('Divination Cards');
                } else if (action === 'poe1-asc-notables') {
                    if (window.OverlayPoe1AscendancyNotables?.show) { try { await window.OverlayPoe1AscendancyNotables.show(); } catch {} }
                    setHeader('Ascendancy Notables');
                    recordHeaderAction('Ascendancy Notables');
                } else if (action === 'poe1-anointments') {
                    if (window.OverlayPoe1Anointments?.show) { try { await window.OverlayPoe1Anointments.show(); } catch {} }
                    setHeader('PoE1 Anointments');
                    recordHeaderAction('PoE1 Anointments');
                } else if (action === 'poe1-tattoos') {
                    if (window.OverlayPoe1Tattoos?.show) { try { await window.OverlayPoe1Tattoos.show(); } catch {} }
                    setHeader('Tattoos');
                    recordHeaderAction('Tattoos');
                } else if (action === 'poe1-gems-list') {
                    if (window.OverlayPoe1Gems?.showList) { try { await window.OverlayPoe1Gems.showList(); } catch {} }
                    setHeader('Gems');
                    recordHeaderAction('Gems');
                } else if (action === 'glossar') {
                    try { await showGlossar(); } catch {}
                    setHeader('Glossar');
                    recordHeaderAction('Glossar');
                }
            });
        });
    }

    // Dedicated unique focus event (from main showUniqueItem)
    if (window.electronAPI && typeof window.electronAPI.onShowUniqueItem !== 'function' && window.electronAPI.on === undefined) {
        // If preload exposes a generic on(channel, cb) you could hook that instead; here we assume a specific registration helper exists.
    }
    // Fallback: poll for a generic API and patch once available
    const attachUniqueHandler = () => {
        try {
            if (window.electronAPI && window.electronAPI.onShowUniqueItem && !window.__xilehudUniqueBound) {
                window.__xilehudUniqueBound = true;
                window.electronAPI.onShowUniqueItem((payload) => {
                    try {
                        // Check if Uniques page is available for current version
                        if (overlayVersionMode !== 'poe2') {
                            console.log('[onShowUniqueItem] PoE2 Uniques not available in', overlayVersionMode, 'mode - ignoring');
                            return;
                        }
                        
                        // Ensure crafting view in Uniques mode
                        setActiveTab('itemsTab');
                        setView('crafting');
                        setHeader('Uniques');
                        recordHeaderAction('Uniques');
                        // Reset scroll containers to top to avoid random offset
                        // Removed forced scroll reset to keep current position
                        // Attempt to render / show uniques panel if not yet loaded
                        const ensure = (attempts=5) => {
                            if (window.OverlayUniques && typeof window.OverlayUniques.show === 'function') {
                                try { showUniques(); } catch {}
                                // Removed auto highlight to prevent unintended scroll movement
                                return;
                            }
                            if (attempts>0) setTimeout(()=>ensure(attempts-1),120);
                        };
                        ensure();
                    } catch (e) { console.warn('unique focus failed', e); }
                });
            }
            
            // PoE1 Unique Item handler
            if (window.electronAPI && window.electronAPI.onShowPoe1UniqueItem && !window.__xilehudPoe1UniqueBound) {
                window.__xilehudPoe1UniqueBound = true;
                window.electronAPI.onShowPoe1UniqueItem((payload) => {
                    try {
                        console.log('[onShowPoe1UniqueItem] Opening PoE1 Uniques:', payload);
                        
                        // Ensure items tab and crafting view for PoE1 Uniques
                        setActiveTab('itemsTab');
                        setView('crafting');
                        setHeader('PoE1 Uniques');
                        recordHeaderAction('PoE1 Uniques');
                        
                        // Attempt to render / show PoE1 uniques panel
                        const ensure = (attempts=5) => {
                            if (window.OverlayPoe1Uniques && typeof window.OverlayPoe1Uniques.show === 'function') {
                                try { 
                                    window.OverlayPoe1Uniques.show(); 
                                    console.log('[onShowPoe1UniqueItem] PoE1 Uniques panel shown');
                                } catch (e) {
                                    console.error('[onShowPoe1UniqueItem] Error showing PoE1 uniques:', e);
                                }
                                return;
                            }
                            if (attempts>0) {
                                console.log('[onShowPoe1UniqueItem] Waiting for PoE1 Uniques module, attempts left:', attempts);
                                setTimeout(()=>ensure(attempts-1),120);
                            } else {
                                console.error('[onShowPoe1UniqueItem] PoE1 Uniques module not available after retries');
                            }
                        };
                        ensure();
                    } catch (e) { 
                        console.error('[onShowPoe1UniqueItem] PoE1 unique focus failed:', e); 
                    }
                });
            }
            
            // PoE1 Gem Detail handler (for copied gems)
            if (window.electronAPI && window.electronAPI.onShowPoe1GemDetail && !window.__xilehudPoe1GemBound) {
                window.__xilehudPoe1GemBound = true;
                window.electronAPI.onShowPoe1GemDetail((payload) => {
                    try {
                        console.log('[onShowPoe1GemDetail] Opening PoE1 Gem:', payload);
                        
                        // Attempt to show gem detail by name
                        const ensure = (attempts=5) => {
                            if (window.OverlayPoe1Gems && typeof window.OverlayPoe1Gems.showDetailByName === 'function') {
                                try { 
                                    window.OverlayPoe1Gems.showDetailByName(payload.gemName); 
                                    console.log('[onShowPoe1GemDetail] PoE1 Gem detail shown for:', payload.gemName);
                                } catch (e) {
                                    console.error('[onShowPoe1GemDetail] Error showing PoE1 gem detail:', e);
                                }
                                return;
                            }
                            if (attempts>0) {
                                console.log('[onShowPoe1GemDetail] Waiting for PoE1 Gems module, attempts left:', attempts);
                                setTimeout(()=>ensure(attempts-1),120);
                            } else {
                                console.error('[onShowPoe1GemDetail] PoE1 Gems module not available after retries');
                            }
                        };
                        ensure();
                    } catch (e) { 
                        console.error('[onShowPoe1GemDetail] PoE1 gem focus failed:', e); 
                    }
                });
            }
        } catch {}
        if (!window.__xilehudUniqueBound) setTimeout(attachUniqueHandler, 300);
    };
    attachUniqueHandler();
    async function runItemsAction(action) {
        if (!action) return;
        setActiveTab('itemsTab');
        closeAllMenus();
        if (itemsMenu) itemsMenu.style.display = 'none';
        setView('crafting');
        if (action === 'uniques') {
            await showUniques();
            setHeader('Uniques');
            recordHeaderAction('Uniques');
            markItemsAction('uniques');
        } else if (action === 'bases') {
            await showBases();
            setHeader('Bases');
            recordHeaderAction('Bases');
            markItemsAction('bases');
        }
    }

        if (itemsTab) {
        itemsTab.addEventListener('click', async (e) => {
            e.stopPropagation();
                const singleAction = itemsTab.getAttribute('data-single-action');
                if (singleAction) {
                    await runItemsAction(singleAction);
                    return;
                }
                setActiveTab('itemsTab');
                const vis = itemsMenu && itemsMenu.style.display === 'block';
                closeAllMenus();
                if (itemsMenu) itemsMenu.style.display = vis ? 'none' : 'block';
        });
        window.addEventListener('click', () => { if (itemsMenu) itemsMenu.style.display = 'none'; });
        if (itemsMenu) itemsMenu.addEventListener('click', (e) => { e.stopPropagation(); });
        if (itemsMenu) itemsMenu.querySelectorAll('.items-menu-item').forEach(item => {
            item.addEventListener('click', async () => {
                const action = item.getAttribute('data-action');
                await runItemsAction(action);
            });
        });
    }
    if (toolsTab) {
        toolsTab.addEventListener('click', (e) => {
            e.stopPropagation();
            setActiveTab('toolsTab');
            const vis = toolsMenu && toolsMenu.style.display === 'block';
            closeAllMenus();
            if (toolsMenu) toolsMenu.style.display = vis ? 'none' : 'block';
        });
        window.addEventListener('click', () => { if (toolsMenu) toolsMenu.style.display = 'none'; });
        if (toolsMenu) toolsMenu.addEventListener('click', (e) => { e.stopPropagation(); });
        if (toolsMenu) toolsMenu.querySelectorAll('.tools-menu-item').forEach(item => {
            item.addEventListener('click', async () => {
                setActiveTab('toolsTab');
                closeAllMenus();
                const action = item.getAttribute('data-action');
                if (toolsMenu) toolsMenu.style.display = 'none';
                if (action === 'regex') {
                    // Regex tool occupies crafting panel style container for now
                    setView('crafting');
                    if (window.OverlayRegex?.show) { try { await window.OverlayRegex.show(); } catch {} }
                    setHeader('Regex Builder');
                    recordHeaderAction('Regex Builder');
                } else if (action === 'poe1-regex') {
                    setView('crafting');
                    if (window.OverlayRegexPoe1?.show) { try { window.OverlayRegexPoe1.show(); } catch {} }
                    setHeader('Map Regex');
                    recordHeaderAction('Map Regex');
                } else if (action === 'poe1-vorici') {
                    setView('crafting');
                    if (window.OverlayPoe1Vorici?.show) { try { await window.OverlayPoe1Vorici.show(); } catch {} }
                    // Apply pending Vorici data if available
                    if (window.pendingVoriciData && window.OverlayPoe1Vorici?.applyItem) {
                        try {
                            window.OverlayPoe1Vorici.applyItem(window.pendingVoriciData);
                            console.log('Applied pending Vorici data');
                        } catch (err) {
                            console.warn('Failed to apply pending Vorici data', err);
                        }
                    }
                    setHeader('Vorici Calculator');
                    recordHeaderAction('Vorici Calculator');
                }
            });
        });
    }
});

// Debounce mechanism to prevent category spam
let switchCategoryLocked = false;
let lastSwitchedCategory = '';
let lastSwitchTime = 0;

// Re-added after accidental removal: handles manual category selection in modifier panel
function switchCategory(){
    const select=document.getElementById('categorySelect');
    if(!select) return;
    syncCategorySelectAppearance();
    const cat=select.value;
    if(!cat) return;
    
    // Debounce: if same category was just loaded within 2 seconds, skip
    const now = Date.now();
    if (cat === lastSwitchedCategory && (now - lastSwitchTime) < 2000) {
        console.log('Category switch debounced (same category within 2s):', cat);
        return;
    }
    
    // Lock: if already loading, queue and skip
    if (switchCategoryLocked) {
        console.log('Category switch locked (already loading):', cat);
        return;
    }
    
    switchCategoryLocked = true;
    lastSwitchedCategory = cat;
    lastSwitchTime = now;
    
    if(!window.electronAPI || !window.electronAPI.getModifierData) {
        switchCategoryLocked = false;
        return;
    }
    // Store current category globally for use in render functions
    window.currentModifierCategory = cat;
    // Ensure we're in Modifiers view; hide other panels and menus
    try {
        setActiveTab('tabModifier');
        setView('modifiers');
        // Close any open dropdown menus
        const craftingMenu = document.getElementById('craftingMenu'); if (craftingMenu) craftingMenu.style.display='none';
        const characterMenu = document.getElementById('characterMenu'); if (characterMenu) characterMenu.style.display='none';
        const itemsMenu = document.getElementById('itemsMenu'); if (itemsMenu) itemsMenu.style.display='none';
        // Hide legacy annoints panel if present
        const ann = document.getElementById('annointsPanel'); if (ann) ann.style.display='none';
    } catch {}
    // Fetch modifier data for chosen category and render a synthetic item context
    window.electronAPI.getModifierData(cat).then(mods=>{
        if(!Array.isArray(mods)){
            console.warn('Category returned non-array', mods);
            switchCategoryLocked = false;
            throw new Error('invalid_data');
        }
        const data={
            item:{ name: cat.replace(/_/g,' '), category: cat, baseType: cat.replace(/_/g,' '), itemClass: cat.replace(/_/g,' ') },
            modifiers: mods
        };
    // Apply mechanics post-processing via module (strongbox/logbook formatting, flags)
    try { window.OverlayModifiers?.mechanicsPostProcess?.(data); } catch {}
    window.originalData=data;
    renderCategoryDetail(data);
    try { setHeader('Modifier', cat.replace(/_/g,' ')); } catch {}
    markModifiersCategory(cat);
    switchCategoryLocked = false; // Unlock after successful load
    }).catch(err=>{
        console.error('switchCategory error', err);
        const content=document.getElementById('content');
        if(content) content.innerHTML=`<div class="no-mods" style="color:var(--accent-red);">Failed to load category (${err?.message||'error'})</div>`;
        switchCategoryLocked = false; // Unlock after error
    });
}

async function openModifiersCategory(cat, options){
    const select = document.getElementById('categorySelect');
    if (!select) return;
    const rawCandidates = Array.isArray(cat) ? cat : [cat];
    const candidates = rawCandidates.map((entry) => String(entry || '').trim()).filter(Boolean);
    if (!candidates.length) return;
    const preferredCandidates = candidates.filter((entry) => normalizeCategoryKey(entry) !== 'ALL');
    const candidatePool = preferredCandidates.length ? preferredCandidates : candidates;

    const buildResolutionMaps = (optionList) => {
        return {
            upperMap: new Map(optionList.map(opt => [(opt.value || '').toUpperCase(), opt.value])),
            normalizedValueMap: new Map(optionList.map(opt => [normalizeCategoryKey(opt.value || ''), opt.value])),
            normalizedLabelMap: new Map(optionList.map(opt => [normalizeCategoryKey(opt.textContent || ''), opt.value]))
        };
    };

    const attemptResolve = (optionList, pool) => {
        if (!optionList.length) return '';
        const maps = buildResolutionMaps(optionList);
        for (const candidate of pool) {
            if (!candidate) continue;
            const upperKey = candidate.toUpperCase();
            if (maps.upperMap.has(upperKey)) return maps.upperMap.get(upperKey) || '';
            const normalizedKey = normalizeCategoryKey(candidate);
            if (normalizedKey) {
                if (maps.normalizedValueMap.has(normalizedKey)) return maps.normalizedValueMap.get(normalizedKey) || '';
                if (maps.normalizedLabelMap.has(normalizedKey)) return maps.normalizedLabelMap.get(normalizedKey) || '';
            }
        }
        return '';
    };

    const resolveFallbackViaOptions = (optionList, pool) => {
        for (const candidate of pool) {
            const normalizedKey = normalizeCategoryKey(candidate);
            if (!normalizedKey || normalizedKey === 'ALL') continue;
            const match = optionList.find(opt => normalizeCategoryKey(opt.value || '') === normalizedKey || normalizeCategoryKey(opt.textContent || '') === normalizedKey);
            if (match) return match.value;
        }
        return '';
    };

    let optionList = Array.from(select.options || []);
    let resolved = attemptResolve(optionList, candidatePool);
    if (!resolved) {
        const optionCount = optionList.length;
        if (optionCount <= 1 && typeof populateCategoryDropdown === 'function') {
            try {
                await populateCategoryDropdown();
            } catch (err) {
                console.warn('[openModifiersCategory] populateCategoryDropdown failed during resolution', err);
            }
            optionList = Array.from(select.options || []);
            resolved = attemptResolve(optionList, candidatePool);
        }
    }

    if (!resolved) {
        resolved = resolveFallbackViaOptions(optionList, candidatePool);
    }

    if (!resolved) {
        const firstUsable = optionList.find(opt => opt.value && normalizeCategoryKey(opt.value) !== 'ALL');
        if (firstUsable) {
            resolved = firstUsable.value;
            console.warn('[openModifiersCategory] Falling back to first available category:', resolved, 'for candidates', candidatePool);
        }
    }

    if (!resolved) {
        console.warn('[openModifiersCategory] Unable to resolve category for candidates:', candidatePool);
        return;
    }

    select.value = resolved;

    syncCategorySelectAppearance();
    if (options && options.bypassDebounce) {
        switchCategoryLocked = false;
        lastSwitchedCategory = '';
        lastSwitchTime = 0;
    }
    try { markModifiersCategory(resolved); } catch {}
    try { setView('modifiers'); } catch {}
    try { switchCategory(); } catch (err) { console.warn('[openModifiersCategory] switchCategory failed:', err); }
}

window.openModifiersCategory = openModifiersCategory;

// ===== Essences Panel delegated to module =====
// (Removed duplicate extended crafting menu handler; actions are wired above.)

// ===== Catalysts delegated to module =====

// ===== Socketables delegated to module =====

// ===== Uniques (Items tab) now delegated to module (see top-level wrappers) =====

// ===== Bases (Items tab) now delegated to module (see top-level wrappers) =====

// ===== Omens delegated to module =====

// ===== Glossar (inline removed; delegated via wrappers defined above) =====

// ===== Glossar (inline removed; delegated via wrappers defined above) =====

// ===== Keystones (Character submenu) =====
async function showKeystones(){
    window.__lastPanel='keystones';
    prepareCharacterPanel('Keystones');
    craftingPanelEl.innerHTML='<div class="no-mods">Loading...</div>';
    try{
        const data = await window.electronAPI.getKeystones();
        if(!data || data.error){ craftingPanelEl.innerHTML=`<div style="color:var(--accent-red);">Failed to load Keystones (${data?.error||'unknown'})</div>`; return; }
        renderKeystones(data.keystones||[]);
    }catch(e){ craftingPanelEl.innerHTML='<div style="color:var(--accent-red);">Exception loading Keystones</div>'; }
}
// ===== Ascendancy Passives (Character submenu) =====
async function showAscendancyPassives(){
    window.__lastPanel='asc_passives';
    prepareCharacterPanel('Ascendancy Passives');
    craftingPanelEl.innerHTML='<div class="no-mods">Loading...</div>';
    try {
        const data = await window.electronAPI.getAscendancyPassives();
        if(!data || data.error){ craftingPanelEl.innerHTML=`<div style="color:var(--accent-red);">Failed to load Ascendancy Passives (${data?.error||'unknown'})</div>`; return; }
        renderAscendancyPassives(data.passives||[]);
    } catch(e){ craftingPanelEl.innerHTML='<div style="color:var(--accent-red);">Exception loading Ascendancy Passives</div>'; }
}
function renderAscendancyPassives(list){
    const panel=craftingPanelEl; if(!panel) return;
    panel.innerHTML=`<div class='page-inner'><div style='display:flex; gap:6px; align-items:center; margin-bottom:8px;'>
        <input id='ascSearch' type='text' placeholder='Search ascendancy passives...' style='flex:1; padding:4px 8px; background:var(--bg-tertiary); border:1px solid var(--border-color); border-radius:4px; color:var(--text-primary); font-size:12px;'>
        <button id='ascClear' class='pin-btn' style='padding:4px 8px;'>Clear</button>
    </div>
    <div style='background:var(--bg-secondary); padding:8px; border-radius:6px; margin-bottom:8px;'>
    <div id='ascClassFilters' style='display:flex; flex-wrap:wrap; gap:6px; justify-content:center; width:100%;'></div>
    </div>
    <div id='ascWrap' style='display:grid; grid-template-columns: repeat(auto-fit, minmax(260px, 1fr)); gap:10px;'></div></div>`;
    const searchEl=panel.querySelector('#ascSearch');
    const clearBtn=panel.querySelector('#ascClear');
    const filterWrap=panel.querySelector('#ascClassFilters');
    const wrap=panel.querySelector('#ascWrap');
    const classes = Array.from(new Set(list.map(p=>p.ascendancy).filter(Boolean))).sort();
    const selected = new Set();
    function chipCss(active){ return `padding:3px 8px; font-size:11px; border-radius:4px; cursor:pointer; border:1px solid var(--border-color); background:${active?'var(--accent-blue)':'var(--bg-tertiary)'}; color:${active?'#fff':'var(--text-primary)'};`; }
    function renderFilters(){ if(!filterWrap) return; filterWrap.innerHTML=''; classes.forEach(c=>{ const active=selected.has(c); const btn=document.createElement('button'); btn.textContent=c; btn.style.cssText=chipCss(active); btn.addEventListener('click',()=>{ if(active) selected.delete(c); else selected.add(c); build(searchEl.value||''); renderFilters(); }); filterWrap.appendChild(btn); }); if(selected.size){ const reset=document.createElement('button'); reset.textContent='Reset'; reset.style.cssText='padding:3px 8px; font-size:11px; border-radius:4px; cursor:pointer; background:var(--accent-red); color:#fff; border:1px solid var(--accent-red);'; reset.addEventListener('click',()=>{ selected.clear(); build(''); renderFilters(); }); filterWrap.appendChild(reset);} }
    function highlight(s){ return (s||"")
       .replace(/(\d+\s*[â€“-]\s*\d+)/g,'<span class="mod-value">$1</span>')
       .replace(/(?<![A-Za-z0-9>])([+\-]?\d+)(?![A-Za-z0-9<])/g,'<span class="mod-value">$1</span>')
       .replace(/(\d+%)/g,'<span class="mod-value">$1</span>'); }
    function matchesClass(p){ if(!selected.size) return true; return selected.has(p.ascendancy); }
    function build(filter=''){
        if(!wrap) return; wrap.innerHTML='';
        const f=filter.toLowerCase();
        const filtered = list.filter(p=>{ const blob=`${p.name} ${(p.explicitMods||[]).join(' ')}`.toLowerCase(); const searchOk = !f || blob.includes(f); return searchOk && matchesClass(p); });
        filtered.forEach(p=>{
            const card=document.createElement('div');
            card.style.background='var(--bg-card)';
            card.style.border='1px solid var(--border-color)';
            card.style.borderRadius='6px';
            card.style.padding='6px';
            card.style.display='flex';
            card.style.flexDirection='column';
            card.style.gap='4px';
            // Clean mods: remove inline skill icons (grantsSkill) then highlight numbers
            const cleanedMods = (p.explicitMods||[]).map(m=> m.replace(/<img[^>]*grantsSkill[^>]*>/ig,'').replace(/<img[^>]*>/ig,'').trim()).filter(Boolean);
            const mods = cleanedMods.map(m=>highlight(m)).join('<br>');
            const _ap = getImagePath(p);
            const imgHtml = p.image || p.imageLocal ? `<img src='' data-orig-src='${_ap}' class='asc-img' style='width:46px; height:46px; object-fit:contain; flex:0 0 46px;'>` : '';
            const metaParts = [];
            if(p.ascendancy) metaParts.push(`<span style="background:var(--accent-blue); color:#fff; padding:2px 8px; border-radius:12px; font-size:11px; font-weight:600; letter-spacing:0.3px;">${p.ascendancy}</span>`);
            if(p.character) metaParts.push(`<span style="background:var(--bg-tertiary); color:var(--text-primary); padding:2px 8px; border-radius:12px; font-size:11px;">${p.character}</span>`);
            if(p.stack_current!=null && p.stack_max!=null) metaParts.push(`<span>Stack: ${p.stack_current} / ${p.stack_max}</span>`);
            card.innerHTML = `<div style='display:flex; gap:10px; align-items:flex-start;'>${imgHtml}<div style='display:flex; flex-direction:column; gap:6px; flex:1;'><div style='font-weight:600; font-size:13px;'>${p.name}</div><div style='display:flex; gap:6px; flex-wrap:wrap;'>${metaParts.join('')}</div><div style='font-size:11px;'>${mods}</div></div></div>`;
            wrap.appendChild(card);
        });
        const svg = "<svg xmlns='http://www.w3.org/2000/svg' width='30' height='30' viewBox='0 0 30 30'><rect width='30' height='30' rx='6' fill='#222'/><text x='50%' y='50%' dominant-baseline='middle' text-anchor='middle' fill='#555' font-size='9' font-family='sans-serif'>?</text></svg>";
        const placeholder = 'data:image/svg+xml;utf8,'+encodeURIComponent(svg);
    wrap.querySelectorAll('img.asc-img').forEach(img=>{ if(img._fb) return; img._fb=true; img.addEventListener('error',()=>{ img.src=placeholder; img.style.opacity='0.5'; img.style.filter='grayscale(1)'; },{once:true}); img.addEventListener('load',()=>{ if(img.src!==placeholder){ img.style.opacity='1'; img.style.filter='none'; } }, { once:true }); });
    }
    searchEl.addEventListener('input',()=>build(searchEl.value));
    clearBtn.addEventListener('click',()=>{ searchEl.value=''; selected.clear(); build(''); renderFilters(); searchEl.focus(); });
    build('');
    renderFilters();
}
function renderKeystones(list){
    const panel=craftingPanelEl; if(!panel) return;
    panel.innerHTML=`<div class='page-inner'><div style='display:flex; gap:6px; align-items:center; margin-bottom:8px;'>
        <input id='keystoneSearch' type='text' placeholder='Search keystones...' style='flex:1; padding:4px 8px; background:var(--bg-tertiary); border:1px solid var(--border-color); border-radius:4px; color:var(--text-primary); font-size:12px;'>
        <button id='keystoneClear' class='pin-btn' style='padding:4px 8px;'>Clear</button>
    </div>
    <div style='background:var(--bg-secondary); padding:8px; border-radius:6px; margin-bottom:8px;'>
    <div id='keystoneTagFilters' style='display:flex; flex-wrap:wrap; gap:6px; justify-content:center; width:100%;'></div>
    </div>
    <div id='keystoneWrap' style='display:grid; grid-template-columns:repeat(auto-fit,minmax(260px,1fr)); gap:10px; align-items:stretch;'></div></div>`;
    // Don't set inline display:none - let CSS handle visibility via body classes
    const searchEl=panel.querySelector('#keystoneSearch');
    const clearBtn=panel.querySelector('#keystoneClear');
    const tagWrap=panel.querySelector('#keystoneTagFilters');
    const wrap=panel.querySelector('#keystoneWrap');
    // Tag coloring helpers
    function tagRGB(tag){ const t=(tag||'').toLowerCase();
        if(t==='fire' || t==='life') return [220,68,61];
        if(t==='cold' || t==='mana') return [66,165,245];
        if(t==='lightning') return [255,213,79];
        if(t==='chaos' || t==='minion') return [156,39,176];
        if(t==='energy shield' || t==='es') return [38,198,218];
        if(t==='defences' || t==='armour' || t==='armor') return [109,76,65];
        if(t==='evasion') return [46,125,50];
        if(t==='resistances') return [255,112,67];
        if(t==='projectile') return [255,179,0];
        if(t==='area') return [171,71,188];
        if(t==='critical' || t==='crit') return [255,179,0];
        if(t==='spell') return [92,107,192];
        if(t==='attack') return [121,85,72];
        if(t==='damage' || t==='ailments' || t==='mechanics') return [96,125,139];
        if(t==='movement' || t==='attack speed' || t==='speed') return [67,160,71];
        if(t==='elemental') return [255,152,0];
        return [120,144,156]; }
    function chipCss(tag, active){ const [r,g,b]=tagRGB(tag); const bg = active? `rgba(${r},${g},${b},0.9)` : `rgba(${r},${g},${b},0.22)`; const border=`rgba(${r},${g},${b},0.6)`; const luma=0.2126*r+0.7152*g+0.0722*b; const color = active ? (luma>180? '#000':'#fff') : 'var(--text-primary)'; return `border:1px solid ${border}; background:${bg}; color:${color}; border-radius:4px;`; }
    // Curated tag set same as Annoints
    const curatedTags = ['Damage','Ailments','Attributes','Energy Shield','Defences','Life','Mana','Fire','Cold','Lightning','Chaos','Resistances','Projectile','Area','Critical','Spell','Attack','Minion','Mechanics'];
    const selected = new Set();
    // Derive tags from keystone text
    function deriveTags(k){ const text=`${k.name||''} ${String(k.description||'')}`; const tags=new Set();
        if(/Damage/i.test(text)) tags.add('Damage');
        if(/Ailment|Bleed|Ignite|Chill|Freeze|Shock|Poison|Stun|Electrocute/i.test(text)) tags.add('Ailments');
        if(/Attribute|Strength|Dexterity|Intelligence/i.test(text)) tags.add('Attributes');
        if(/Energy Shield|\bES\b/i.test(text)) tags.add('Energy Shield');
        if(/Armour|Armor|Evasion/i.test(text)) tags.add('Defences');
        if(/\bLife\b/i.test(text)) tags.add('Life');
        if(/\bMana\b/i.test(text)) tags.add('Mana');
        if(/\bFire\b/i.test(text)) tags.add('Fire');
        if(/\bCold\b/i.test(text)) tags.add('Cold');
        if(/Lightning|Electrocute/i.test(text)) tags.add('Lightning');
        if(/\bChaos\b/i.test(text)) tags.add('Chaos');
        if(/Resist/i.test(text)) tags.add('Resistances');
        if(/Projectile/i.test(text)) tags.add('Projectile');
        if(/\bArea\b/i.test(text)) tags.add('Area');
        if(/Critical/i.test(text)) tags.add('Critical');
        if(/Cast|Spell/i.test(text)) tags.add('Spell');
        if(/\bAttack\b/i.test(text)) tags.add('Attack');
        if(/Minion/i.test(text)) tags.add('Minion');
        if(/Trap|Totem|Trigger/i.test(text)) tags.add('Mechanics');
        return [...tags]; }
    // Precompute item tags and counts
    list.forEach(k=>{ k.__tags = deriveTags(k); });
    const tagCounts = Object.fromEntries(curatedTags.map(t=>[t,0]));
    list.forEach(k=> (k.__tags||[]).forEach(t=>{ if(tagCounts[t]!=null) tagCounts[t]++; }));
    function renderTagFilters(){ if(!tagWrap) return; tagWrap.innerHTML=''; curatedTags.forEach(tag=>{ const active=selected.has(tag.toLowerCase()); const btn=document.createElement('button'); const count=tagCounts[tag]||0; btn.className='key-tag'; btn.setAttribute('data-tag', tag.toLowerCase()); btn.textContent = count? `${tag} (${count})` : tag; btn.style.cssText = `padding:3px 8px; font-size:11px; cursor:pointer; ${chipCss(tag, active)}`; btn.addEventListener('click',()=>{ if(active) selected.delete(tag.toLowerCase()); else selected.add(tag.toLowerCase()); build(searchEl.value||''); renderTagFilters(); }); tagWrap.appendChild(btn); }); if(selected.size){ const reset=document.createElement('button'); reset.textContent='Reset'; reset.style.cssText='padding:3px 8px; font-size:11px; border-radius:4px; cursor:pointer; background:var(--accent-red); color:#fff; border:1px solid var(--accent-red);'; reset.addEventListener('click',()=>{ selected.clear(); build(''); renderTagFilters(); }); tagWrap.appendChild(reset); } }
    function matchTags(k){ if(!selected.size) return true; const lc=(k.__tags||[]).map(t=>t.toLowerCase()); return [...selected].every(t=> lc.includes(t)); }
    function build(filter=''){
        wrap.innerHTML='';
        const f=filter.toLowerCase();
        list.filter(k=>{ const matchesSearch = !f || k.name.toLowerCase().includes(f) || (k.description||'').toLowerCase().includes(f); return matchesSearch && matchTags(k); }).forEach(k=>{
            const card=document.createElement('div');
            card.className='keystone-card';
            card.style.background='var(--bg-card)';
            card.style.border='1px solid var(--border-color)';
            card.style.borderRadius='6px';
            card.style.padding='6px';
            card.style.display='flex';
            card.style.flexDirection='column';
            card.style.gap='4px';
            card.style.height='100%';
            const kp = getImagePath(k);
            const imgHtml = k.image || k.imageLocal ? `<img src='' data-orig-src='${kp}' class='keystone-img' style='width:30px; height:30px; object-fit:contain;'>` : `<img src='' class='keystone-img' style='width:30px; height:30px; object-fit:contain;'>`;
            card.innerHTML=`<div style='display:flex; gap:6px; align-items:center;'>${imgHtml}<div style='font-weight:600;'>${k.name}</div></div><div style='font-size:11px;'>${k.description||''}</div>`;
            wrap.appendChild(card);
        });
        // Image fallback placeholder
        const placeholderSvg = `data:image/svg+xml;utf8,${encodeURIComponent(`<svg xmlns='http://www.w3.org/2000/svg' width='30' height='30' viewBox='0 0 30 30'><rect width='30' height='30' rx='6' fill='#222'/><text x='50%' y='50%' dominant-baseline='middle' text-anchor='middle' fill='#555' font-size='9' font-family='sans-serif'>?</text></svg>`)}`;
        wrap.querySelectorAll('img.keystone-img').forEach(function(img){
            if(img._fb) return; img._fb=true; img.loading= img.loading || 'lazy'; img.decoding='async';
            img.addEventListener('error', function(){ img.src=placeholderSvg; img.style.opacity='0.5'; img.style.filter='grayscale(1)'; });
            img.addEventListener('load', function(){ if(img.src!==placeholderSvg){ img.style.opacity='1'; img.style.filter='none'; }});
        });
    }
    searchEl.addEventListener('input',()=>build(searchEl.value));
    clearBtn.addEventListener('click',()=>{searchEl.value=''; selected.clear(); build(''); renderTagFilters(); searchEl.focus();});
    build('');
    renderTagFilters();
}
    // ===== Atlas Nodes (Character submenu) =====
async function showAtlasNodes(){
    window.__lastPanel='atlas_nodes';
    prepareCharacterPanel('Atlas Nodes');
    craftingPanelEl.innerHTML='<div class="no-mods">Loading...</div>';
    try{
        const data = await window.electronAPI.getAtlasNodes();
        if(!data || data.error){ craftingPanelEl.innerHTML=`<div style="color:var(--accent-red);">Failed to load Atlas Nodes (${data?.error||'unknown'})</div>`; return; }
        renderAtlasNodes(data.nodes||[]);
    }catch(e){ craftingPanelEl.innerHTML='<div style="color:var(--accent-red);">Exception loading Atlas Nodes</div>'; }
}
function renderAtlasNodes(list){
    const panel=craftingPanelEl; if(!panel) return;
    panel.innerHTML=`<div class='page-inner'><div style='display:flex; gap:6px; align-items:center; margin-bottom:8px;'>
        <input id='atlasSearch' type='text' placeholder='Search atlas nodes...' style='flex:1; padding:4px 8px; background:var(--bg-tertiary); border:1px solid var(--border-color); border-radius:4px; color:var(--text-primary); font-size:12px;'>
        <button id='atlasClear' class='pin-btn' style='padding:4px 8px;'>Clear</button>
    </div>
    <div style='background:var(--bg-secondary); padding:8px; border-radius:6px; margin-bottom:8px;'>
    <div id='atlasTagFilters' style='display:flex; flex-wrap:wrap; gap:6px; justify-content:center; width:100%;'></div>
    </div>
    <div id='atlasWrap' style='display:grid; grid-template-columns: repeat(auto-fit, minmax(320px, 1fr)); gap:10px;'></div></div>`;
    const searchEl=panel.querySelector('#atlasSearch');
    const clearBtn=panel.querySelector('#atlasClear');
    const tagWrap=panel.querySelector('#atlasTagFilters');
    const wrap=panel.querySelector('#atlasWrap');
    function tagRGB(tag){ const t=(tag||'').toLowerCase();
        if(t==='fire' || t==='life') return [220,68,61];
        if(t==='cold' || t==='mana') return [66,165,245];
        if(t==='lightning') return [255,213,79];
        if(t==='chaos' || t==='minion') return [156,39,176];
        if(t==='energy shield' || t==='es') return [38,198,218];
        if(t==='defences' || t==='armour' || t==='armor') return [109,76,65];
        if(t==='evasion') return [46,125,50];
        if(t==='resistances') return [255,112,67];
        if(t==='projectile') return [255,179,0];
        if(t==='area') return [171,71,188];
        if(t==='critical' || t==='crit') return [255,179,0];
        if(t==='spell') return [92,107,192];
        if(t==='attack') return [121,85,72];
        if(t==='damage' || t==='ailments' || t==='mechanics') return [96,125,139];
        if(t==='movement' || t==='attack speed' || t==='speed') return [67,160,71];
        if(t==='elemental') return [255,152,0];
        return [120,144,156]; }
    function chipCss(tag, active){ const [r,g,b]=tagRGB(tag); const bg = active? `rgba(${r},${g},${b},0.9)` : `rgba(${r},${g},${b},0.22)`; const border=`rgba(${r},${g},${b},0.6)`; const luma=0.2126*r+0.7152*g+0.0722*b; const color = active ? (luma>180? '#000':'#fff') : 'var(--text-primary)'; return `border:1px solid ${border}; background:${bg}; color:${color}; border-radius:4px;`; }
    // Requested tag set for Atlas Nodes
    const curatedTags = [
        'quantity','rarity','explicit','prefix','suffix','delirium','breach','expedition','runic','remnants','spirit','ritual','azmeri','essence','strongbox','shrine','boss','waystone','rogue','biome','monster pack size','rare','magic'
    ];
    const selected = new Set();
    function deriveTags(n){ const text=`${n.name||''} ${String(n.description||'')}`.toLowerCase(); const tags=new Set();
        if(/\bquantity\b|item\s+quantity/i.test(text)) tags.add('quantity');
        if(/\brarity\b|item\s+rarity/i.test(text)) tags.add('rarity');
    if(/\bexplicit\b/i.test(text)) tags.add('explicit');
    if(/\bprefix(es)?\b/i.test(text)) tags.add('prefix');
        if(/\bsuffix(es)?\b/i.test(text)) tags.add('suffix');
        if(/\bdelirium\b/i.test(text)) tags.add('delirium');
        if(/\bbreach\b/i.test(text)) tags.add('breach');
        if(/\bexpedition\b/i.test(text)) tags.add('expedition');
        if(/\brunic\b/i.test(text)) tags.add('runic');
        if(/\bremnants?\b/i.test(text)) tags.add('remnants');
        if(/\bspirit\b/i.test(text)) tags.add('spirit');
        if(/\britual\b/i.test(text)) tags.add('ritual');
        if(/\bazmeri\b/i.test(text)) tags.add('azmeri');
        if(/\bessence\b/i.test(text)) tags.add('essence');
        if(/\bstrongbox\b/i.test(text)) tags.add('strongbox');
        if(/\bshrine\b/i.test(text)) tags.add('shrine');
        if(/\bboss\b/i.test(text)) tags.add('boss');
        if(/\bwaystone\b/i.test(text)) tags.add('waystone');
        if(/\brogue\b/i.test(text)) tags.add('rogue');
        if(/\bbiome\b/i.test(text)) tags.add('biome');
        if(/monster\s+pack\s+size/i.test(text)) tags.add('monster pack size');
        if(/\brare\b/i.test(text)) tags.add('rare');
        if(/\bmagic\b/i.test(text)) tags.add('magic');
        return [...tags]; }
    list.forEach(n=>{ n.__tags = deriveTags(n); });
    const tagCounts = Object.fromEntries(curatedTags.map(t=>[t,0]));
    list.forEach(n=> (n.__tags||[]).forEach(t=>{ if(tagCounts[t]!=null) tagCounts[t]++; }));
    function renderTagFilters(){ if(!tagWrap) return; tagWrap.innerHTML=''; curatedTags.forEach(tag=>{ const active=selected.has(tag.toLowerCase()); const btn=document.createElement('button'); const count=tagCounts[tag]||0; btn.className='key-tag'; btn.setAttribute('data-tag', tag.toLowerCase()); btn.textContent = count? `${tag} (${count})` : tag; btn.style.cssText = `padding:3px 8px; font-size:11px; cursor:pointer; ${chipCss(tag, active)}`; btn.addEventListener('click',()=>{ if(active) selected.delete(tag.toLowerCase()); else selected.add(tag.toLowerCase()); build(searchEl.value||''); renderTagFilters(); }); tagWrap.appendChild(btn); }); if(selected.size){ const reset=document.createElement('button'); reset.textContent='Reset'; reset.style.cssText='padding:3px 8px; font-size:11px; border-radius:4px; cursor:pointer; background:var(--accent-red); color:#fff; border:1px solid var(--accent-red);'; reset.addEventListener('click',()=>{ selected.clear(); build(''); renderTagFilters(); }); tagWrap.appendChild(reset); } }
    function matchTags(n){ if(!selected.size) return true; const lc=(n.__tags||[]).map(t=>t.toLowerCase()); return [...selected].every(t=> lc.includes(t)); }
    function build(filter=''){
        wrap.innerHTML='';
        const f=filter.toLowerCase();
        list.filter(n=>{ const matchesSearch = !f || n.name.toLowerCase().includes(f) || (n.description||'').toLowerCase().includes(f); return matchesSearch && matchTags(n); }).forEach(n=>{
            const card=document.createElement('div');
            card.style.background='var(--bg-card)';
            card.style.border='1px solid var(--border-color)';
            card.style.borderRadius='6px';
            card.style.padding='8px';
            card.style.display='flex';
            card.style.flexDirection='column';
            card.style.gap='6px';
            card.style.height='100%';
            const ap=getImagePath(n);
            const title=`<div style='display:flex; align-items:center; gap:6px;'><img src='' data-orig-src='${ap}' class='atlas-img' style='width:28px; height:28px; object-fit:contain;'/><div style='font-weight:700; font-size:15px;'>${n.name}</div></div>`;
            const bodyHtml = (n.description_html || escapeHtml(n.description || '')).trim();
            const body = `<div style='font-size:12px; line-height:1.35;'>${bodyHtml}</div>`;
            card.innerHTML=title+body;
            wrap.appendChild(card);
        });
        // Add image fallback for atlas nodes
        const placeholderSvg = `data:image/svg+xml;utf8,${encodeURIComponent(`<svg xmlns='http://www.w3.org/2000/svg' width='28' height='28' viewBox='0 0 28 28'><rect width='28' height='28' rx='6' fill='#222'/><text x='50%' y='50%' dominant-baseline='middle' text-anchor='middle' fill='#555' font-size='8' font-family='sans-serif'>?</text></svg>`)}`;
        wrap.querySelectorAll('img.atlas-img').forEach(function(img){
            if(img._fb) return; img._fb=true; img.loading='lazy'; img.decoding='async';
            img.addEventListener('error', function(){ img.src=placeholderSvg; img.style.opacity='0.5'; img.style.filter='grayscale(1)'; });
            img.addEventListener('load', function(){ if(img.src!==placeholderSvg){ img.style.opacity='1'; img.style.filter='none'; }});
        });
    }
    searchEl.addEventListener('input',()=>build(searchEl.value));
    clearBtn.addEventListener('click',()=>{ searchEl.value=''; build(''); searchEl.focus(); });
    // Prevent any stray anchor clicks inside list
    panel.addEventListener('click',(e)=>{ const target = e.target && ((e.target)); const a = target && target.closest ? target.closest('a') : null; if(a){ e.preventDefault(); e.stopPropagation(); }});
    renderTagFilters();
    build('');
}

// ===== Gems (Character submenu) =====
async function showGems(){
    window.__lastPanel='gems';
    prepareCharacterPanel('Gems');
    craftingPanelEl.innerHTML='<div class="no-mods">Loading...</div>';
    // Reset scroll position to top when showing gems (with delay to ensure content is rendered)
    setTimeout(() => {
        if (craftingPanelEl) craftingPanelEl.scrollTop = 0;
    }, 10);
    try{
        const data = await window.electronAPI.getGems();
        if(!data || data.error){ craftingPanelEl.innerHTML=`<div style=\"color:var(--accent-red);\">Failed to load Gems (${data?.error||'unknown'})</div>`; return; }
        renderGems(data.gems||{});
    }catch(e){ craftingPanelEl.innerHTML='<div style=\"color:var(--accent-red);\">Exception loading Gems</div>'; }
}
function renderGems(groups){
    const panel=craftingPanelEl; if(!panel) return;
    const order=[["skill","Skill Gems"],["support","Support Gems"],["spirit","Spirit Gems"],["lineage","Lineage Supports"]];
    const skillTags=new Set();
    order.forEach(([key, label]) => { (groups[key]||[]).forEach(g => { (g.tags||[]).filter(Boolean).forEach(tag => skillTags.add(tag)); }); });
    const sortedTags=[...skillTags].sort((a,b)=>a.localeCompare(b));
    const tagCounts = {};
    order.forEach(([key])=>{ (groups[key]||[]).forEach(g=>{ (g.tags||[]).forEach(t=>{ tagCounts[t] = (tagCounts[t]||0)+1; }); }); });
    panel.innerHTML=`<div style='display:flex; gap:6px; align-items:center; margin-bottom:6px;'>
        <input id='gemSearch' type='text' placeholder='Search gems...' style='flex:1; padding:4px 8px; background:var(--bg-tertiary); border:1px solid var(--border-color); border-radius:4px; color:var(--text-primary); font-size:12px;'>
        <button id='gemClear' class='pin-btn' style='padding:4px 8px;'>Clear</button>
    </div>
    <div style='display:flex; justify-content:space-between; align-items:center; gap:8px; margin-bottom:4px;'>
    <div style='background:var(--bg-secondary); padding:8px; border-radius:6px; flex:1;'>
    <div id='gemTagFilters' style='display:flex; flex-wrap:wrap; gap:4px; justify-content:center; width:100%;'></div>
    </div>
      <button id='gemImgLogBtn' title='Show recent image request log' style='padding:2px 6px; font-size:11px; background:var(--bg-tertiary); border:1px solid var(--border-color); border-radius:4px; cursor:pointer;'>Img Log</button>
    </div>
    <div id='gemImgDiag' style='display:none; flex-direction:column; gap:4px; margin-bottom:8px;'></div>
    <div id='gemSections' style='display:flex; flex-direction:column; gap:14px;'></div>`;
    const searchEl=panel.querySelector('#gemSearch');
    const clearBtn=panel.querySelector('#gemClear');
    const container=panel.querySelector('#gemSections');
    const tagWrap=panel.querySelector('#gemTagFilters');
    const imgDiag=panel.querySelector('#gemImgDiag');
    const imgLogBtn=panel.querySelector('#gemImgLogBtn');
    if(imgLogBtn) imgLogBtn.style.display='none';
    const selectedTags=new Set();
    function tagRGB(tag){ const t=(tag||'').toLowerCase();
        if(t==='fire' || t==='life') return [220,68,61];
        if(t==='cold' || t==='mana') return [66,165,245];
        if(t==='lightning') return [255,213,79];
        if(t==='chaos' || t==='minion') return [156,39,176];
        if(t==='energy shield' || t==='es') return [38,198,218];
        if(t==='armour' || t==='armor' || t==='defences') return [109,76,65];
        if(t==='evasion') return [46,125,50];
        if(t==='resistances' || t==='resist') return [255,112,67];
        if(t==='projectile') return [255,179,0];
        if(t==='area') return [171,71,188];
        if(t==='critical' || t==='crit') return [255,179,0];
        if(t==='spell') return [92,107,192];
        if(t==='attack') return [121,85,72];
        if(t==='damage' || t==='ailments' || t==='mechanics') return [96,125,139];
        if(t==='movement' || t==='attack speed' || t==='speed') return [67,160,71];
        if(t==='elemental') return [255,152,0];
        return [120,144,156]; }
    function chipCss(tag, active){ const [r,g,b]=tagRGB(tag); const bg = active? `rgba(${r},${g},${b},0.9)` : `rgba(${r},${g},${b},0.22)`; const border=`rgba(${r},${g},${b},0.6)`; const luma=0.2126*r+0.7152*g+0.0722*b; const color = active ? (luma>180? '#000':'#fff') : 'var(--text-primary)'; return `border:1px solid ${border}; background:${bg}; color:${color}; border-radius:4px;`; }
    function renderTagFilters(){ if(!tagWrap) return; tagWrap.innerHTML=''; sortedTags.forEach(tag=>{ const btn=document.createElement('div'); const active=selectedTags.has(tag); const count = tagCounts[tag]||0; btn.textContent = count ? `${tag} (${count})` : tag; btn.style.cssText = `cursor:pointer; user-select:none; padding:2px 6px; font-size:11px; ${chipCss(tag, active)}`; btn.addEventListener('click',()=>{ active?selectedTags.delete(tag):selectedTags.add(tag); build(searchEl.value||''); renderTagFilters(); }); tagWrap.appendChild(btn); }); if(selectedTags.size){ const reset=document.createElement('div'); reset.textContent='Reset'; reset.style.cursor='pointer'; reset.style.userSelect='none'; reset.style.padding='2px 6px'; reset.style.fontSize='11px'; reset.style.border='1px solid var(--accent-red)'; reset.style.borderRadius='4px'; reset.style.background='var(--accent-red)'; reset.style.color='#fff'; reset.addEventListener('click',()=>{ selectedTags.clear(); build(searchEl.value||''); renderTagFilters(); }); tagWrap.appendChild(reset); } }
    function gemMatches(g){ if(selectedTags.size===0) return true; const desc=(g.description||'').toLowerCase(); return [...selectedTags].every(t=> (g.tags&&g.tags.includes(t)) || desc.includes(t.toLowerCase())); }
    function build(filter=''){
        container.innerHTML='';
        const f=filter.toLowerCase();
        order.forEach(([key,label])=>{
            const list=(groups[key]||[]).filter(g=>{
                const matchesSearch=!f || g.name.toLowerCase().includes(f) || (g.type||'').toLowerCase().includes(f) || (g.description||'').toLowerCase().includes(f);
                return matchesSearch && gemMatches(g);
            });
            if(!list.length) return;
            const section=document.createElement('div');
            section.innerHTML=`<div style='font-weight:600; font-size:14px; margin-bottom:4px;'>${label} (${list.length})</div>`;
            const wrap=document.createElement('div'); wrap.style.display='grid'; wrap.style.gridTemplateColumns='repeat(auto-fit, minmax(230px, 1fr))'; wrap.style.gap='10px';
            list.forEach(g=>{
                const card=document.createElement('div');
                card.style.background='var(--bg-card)'; card.style.border='1px solid var(--border-color)'; card.style.borderRadius='6px'; card.style.padding='6px'; card.style.display='flex'; card.style.flexDirection='column'; card.style.gap='4px';
                const gp = getImagePath(g);
                const imgHtml = g.image || g.imageLocal ?`<img class='gem-img' src='' data-orig-src='${gp}' loading='lazy' decoding='async' style='width:28px; height:28px; object-fit:contain;'>`:'';
                const base=`<div style='display:flex; gap:6px; align-items:center;'>${imgHtml}<div style='font-weight:600;'>${g.name}</div></div><div style='font-size:10px; color:var(--text-muted);'>${g.type||''}</div><div style='font-size:11px; max-height:120px; overflow:auto;'>${g.description||''}</div>`;
                const tagsRow = `<div style='font-size:10px; display:flex; flex-wrap:wrap; gap:4px;'>${(g.tags||[]).length? (g.tags||[]).map(t=>'<span style="background:var(--bg-tertiary); padding:2px 4px; border-radius:3px; line-height:1;">'+t+'</span>').join('') : '<span style="opacity:.5;">No tags</span>'}</div>`;
                card.innerHTML=base+tagsRow;
                wrap.appendChild(card);
            });
            section.appendChild(wrap); container.appendChild(section);
        });
        // Image fallback
                const placeholder='data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="28" height="28" viewBox="0 0 28 28"><rect width="28" height="28" rx="4" fill="%23222"/><text x="50%" y="50%" dominant-baseline="middle" text-anchor="middle" fill="%23555" font-size="8" font-family="sans-serif">?</text></svg>';
                container.querySelectorAll('img.gem-img').forEach(img=>{
                    if(img._fb)return; img._fb=true; const orig=img.getAttribute('data-orig-src')||img.src; img.setAttribute('data-orig-src', orig);
                    img.addEventListener('error',()=>{
                        if(!img.dataset.retry){ img.dataset.retry='1'; const bust=orig+(orig.includes('?')?'&':'?')+'r='+Date.now(); img.src=bust; return; }
                        img.src=placeholder; img.style.opacity='0.55'; img.style.filter='grayscale(1)';
                        try { (window).__imageErrorEvents = (window).__imageErrorEvents || []; (window).__imageErrorEvents.push({ ts:Date.now(), phase:'failed', src:orig }); } catch {}
                    });
                });
    }
    searchEl.addEventListener('input',()=>build(searchEl.value));
    clearBtn.addEventListener('click',()=>{ searchEl.value=''; build(''); searchEl.focus(); });
        imgLogBtn.addEventListener('click', async ()=>{
                try {
                    const log = await window.electronAPI.getImageLog?.();
                    if(!imgDiag)return; if(!log||!log.length){ imgDiag.style.display='flex'; imgDiag.innerHTML='<div style="font-size:11px; color:var(--text-muted);">No image log entries.</div>'; return; }
                    imgDiag.style.display='flex';
                    imgDiag.innerHTML = `<div style='font-size:11px; font-weight:600;'>Recent Image Requests (${log.length})</div>`+
                        `<div style='max-height:160px; overflow:auto; font-size:10px; line-height:1.25; background:var(--bg-tertiary); padding:4px; border:1px solid var(--border-color); border-radius:4px;'>`+
                        log.slice().reverse().map(e=>`<div style='margin-bottom:4px;'>${e.status?`<span style='color:${e.status>=200&&e.status<300?'#6fbf73':'var(--accent-red)'};'>${e.status}</span>`:`<span style='color:var(--accent-red);'>ERR</span>`} <span style='opacity:.7;'>${e.method}</span> <span>${e.url}</span>${e.error?`<div style='color:var(--accent-red);'>${e.error}</div>`:''}</div>`).join('')+
                        `</div>`;
                        // Attempt a targeted retry for 403 images (might succeed with new headers)
                                    const forbidden = (log||[]).filter(e=>e.status===403).map(e=>e.url);
                                    if(forbidden.length){
                                        const allImgs = Array.from(document.querySelectorAll('img.gem-img'));
                                        allImgs.forEach(function(img){
                                            var orig = img.getAttribute('data-orig-src') || img.src;
                                            if(forbidden.includes(orig) && !img.dataset.retry403){
                                                img.dataset.retry403='1';
                                                setTimeout(function(){ img.src = orig + (orig.includes('?')?'&':'?')+'reh='+Date.now(); }, 100);
                                            }
                                        });
                                    }
                } catch(err) {
                    if(imgDiag){ imgDiag.style.display='flex'; imgDiag.innerHTML='<div style="color:var(--accent-red); font-size:11px;">Failed to fetch image log</div>'; }
                }
        });
        build('');
        renderTagFilters();
    // Shared debug hotkey (Ctrl+Shift+I) to toggle gem img log button
    if(!window.__gemImgDebugHotkey){
        window.__gemImgDebugHotkey=true;
        window.addEventListener('keydown',function(e){
            if(e.ctrlKey && e.shiftKey && e.code==='KeyI'){
                if(imgLogBtn){ imgLogBtn.style.display = imgLogBtn.style.display==='none' ? '' : 'none'; }
            }
        });
    }
}

// --- Generic auto-resolve for bundled images (gems / atlas / ascendancy / keystones / bases / uniques) ---
// NEW SYSTEM: Images use imageLocal field with clean paths like "keystones/avatar_of_fire.webp"
// This resolver converts those to file:// URLs and also handles legacy URL-based images as fallback.
(function(){
    // Generic resolver for any <img data-orig-src> left unhandled by module-specific bindImageFallback.
    function resolveImg(img){
        if(!img || img.dataset._genericResolved) return;
        const orig = img.getAttribute('data-orig-src');
        if(!orig) return;
        // If already has a non-empty src, skip.
        if(img.getAttribute('src')) { return; }
        const finish = (u) => {
            if(!u) return;
            img.src = u;
            img.dataset._genericResolved = '1';
            // Clear any placeholder styling if set earlier
            requestAnimationFrame(()=>{ if(img.src && !/data:image\/svg/i.test(img.src)){ img.style.opacity='1'; img.style.filter='none'; } });
        };
        try {
            if(/^file:|^data:/.test(orig)) { return finish(orig); }
            if((window).bundledImages && (window).bundledImages.toFileUrl){ finish((window).bundledImages.toFileUrl(orig)); return; }
            if((window).electronAPI && (window).electronAPI.getBundledImagePath){
                (window).electronAPI.getBundledImagePath(orig).then(u=>{ if(!img.dataset._genericResolved && u) finish(u); });
                return;
            }
            // Last resort: try using orig directly (may 404, error handlers will catch)
            finish(orig);
        } catch {}
    }
    function scan(){ document.querySelectorAll('img[data-orig-src]').forEach(i=>{ if(!i.getAttribute('src')) resolveImg(i); }); }
    setTimeout(scan, 5);
    new MutationObserver(()=>scan()).observe(document.documentElement,{childList:true,subtree:true});
    document.addEventListener('DOMContentLoaded', scan);
})();

// Bottom resize handle wiring (vertical resize)
(function(){
    const handle = document.getElementById('resizeHandle');
    if (!handle || !window.electronAPI || typeof window.electronAPI.resizeOverlayHeight !== 'function') return;
    let startY = 0; let startH = 0; let dragging = false; let raf = 0;
    const onMove = (ev) => {
        if (!dragging) return;
        const dy = ev.clientY - startY;
        const target = Math.max(200, startH + dy);
        if (raf) cancelAnimationFrame(raf);
        raf = requestAnimationFrame(()=>{ try { window.electronAPI.resizeOverlayHeight(target); } catch {} });
    };
    const onUp = () => {
        dragging = false;
        window.removeEventListener('mousemove', onMove);
        window.removeEventListener('mouseup', onUp);
    };
    handle.addEventListener('mousedown', (ev)=>{
        ev.preventDefault(); ev.stopPropagation();
        startY = ev.clientY; startH = window.innerHeight; dragging = true;
        window.addEventListener('mousemove', onMove);
        window.addEventListener('mouseup', onUp);
    });
})();
                </script>
                <script>
                // IPC glue for tray / main-process actions
                (function(){
                    if (window.electronAPI) {
                        try {
                            window.electronAPI.onSetActiveTab?.((tab)=>{
                                if (tab === 'modifiers') {
                                    if (!featureAvailability.modifiers) return;
                                    const modTab = document.getElementById('tabModifier');
                                    if (!modTab || window.getComputedStyle(modTab).display === 'none') return;
                                    setActiveTab('tabModifier');
                                    setView('modifiers');
                                }
                                if (tab === 'crafting' || tab === 'character') {
                                    if (!featureAvailability.crafting) return;
                                    setActiveTab(tab === 'character' ? 'characterTab' : 'craftingTab');
                                    setView('crafting');
                                }
                                if (tab === 'history') {
                                    if (!featureAvailability.history) return;
                                    const histTab = document.getElementById('tabHistory');
                                    if (!histTab || window.getComputedStyle(histTab).display === 'none') return;
                                    setActiveTab('tabHistory');
                                    setView('history');
                                    try { setHeader('Merchant History'); } catch {}
                                }
                            });
                            window.electronAPI.onInvokeAction?.(async (action)=>{
                                if (action === 'regex') {
                                    try { if (window.OverlayRegex?.show) { window.OverlayRegex.show(); setHeader('Regex'); } } catch {}
                                }
                                if (action === 'merchant-history') {
                                    if (!featureAvailability.history) return;
                                    const histBtn = document.getElementById('tabHistory');
                                    histBtn?.click?.();
                                }
                                if (action === 'socketables') {
                                    try {
                                        closeAllMenus(); // Close the crafting dropdown menu
                                        if (window.OverlaySocketables?.show) { 
                                            window.OverlaySocketables.show(); 
                                            setHeader('Socketables'); 
                                        } 
                                    } catch {}
                                }
                                if (action === 'gems') {
                                    try {
                                        if (!featureAvailability.character) {
                                            console.log('[onInvokeAction] Character view disabled - skipping gems');
                                            return;
                                        }
                                        setActiveTab('characterTab');
                                        setView('character');
                                        if (overlayVersionMode === 'poe2') {
                                            await showGems();
                                        } else {
                                            if (window.OverlayPoe1Gems?.showList) {
                                                await window.OverlayPoe1Gems.showList();
                                            }
                                        }
                                        setHeader('Gems');
                                        recordHeaderAction('Gems');
                                    } catch {}
                                }
                            });
                            // Respond to category selection from main
                            window.electronAPI.onSetActiveCategory?.(async (cat)=>{
                                try {
                                    const normalized = String(cat || '').toLowerCase();
                                    if (normalized === 'socketables') {
                                        closeAllMenus();
                                        setActiveTab('craftingTab');
                                        setView('crafting');
                                        try { await showSocketables(); } catch {}
                                        setHeader('Socketables');
                                        recordHeaderAction('Socketables');
                                        return;
                                    }
                                    const select = document.getElementById('categorySelect');
                                    if (select) { select.value = cat; select.dispatchEvent(new Event('change')); }
                                } catch {}
                            });
                            window.electronAPI.onShowDefaultView?.(() => {
                                openLastOrDefault();
                            });
                            // Handle history popout refresh requests
                            window.electronAPI.onRequestHistoryPopoutRefresh?.(async ()=>{
                                try {
                                    if (typeof window.OverlayHistory?.onPopoutRefresh === 'function') {
                                        await window.OverlayHistory.onPopoutRefresh();
                                    }
                                } catch (e) {
                                    console.error('Failed to handle popout refresh:', e);
                                }
                            });
                            // Handle league change from settings
                            window.electronAPI.onHistoryLeagueChanged?.(async (data)=>{
                                try {
                                    console.log('[Overlay] League changed from settings:', data);
                                    if (typeof window.OverlayHistory?.handleLeagueChangeFromSettings === 'function') {
                                        await window.OverlayHistory.handleLeagueChangeFromSettings(data.league, data.source);
                                    }
                                } catch (e) {
                                    console.error('Failed to handle league change:', e);
                                }
                            });
                        } catch {}
                    }
                })();
                </script>
</html>